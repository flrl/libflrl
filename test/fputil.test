#include "test/unitmain.h"

#include "src/fputil.c"

#include <float.h>
#include <math.h>
#include <stdio.h>

#define TEST_EPSILON (0) /* XXX not actually used by assert_float_equal()! */

static void fn_kbn_sumf32v(NO_STATE)
{
    const struct {
        float values[16];
        size_t n_values;
        double expect_sum;
    } tests[] = {
        { { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 },
          12, 78.0 },
        { { 1.0, powf(10.0, 37.0), 1.0, -powf(10.0, 37.0) },
          4, 2.0 },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    unsigned i;

    for (i = 0; i < n_tests; i++) {
        double kbn_sum = kbn_sumf32v(tests[i].values, tests[i].n_values);
        double naive_sum = 0.0;
        unsigned j;
        const char *sep = "";

        if (verbose) {
            for (j = 0; j < tests[i].n_values; j++) {
                naive_sum += tests[i].values[j];
                printf("%s%.*g", sep, FLT_DECIMAL_DIG, tests[i].values[j]);
                sep = " + ";
            }
            printf(" = kbn: %.*g naive: %.*g expected: %.*g\n",
                   DBL_DECIMAL_DIG, kbn_sum,
                   DBL_DECIMAL_DIG, naive_sum,
                   DBL_DECIMAL_DIG, tests[i].expect_sum);
        }

        /* XXX assert_double_equal */
        assert_true(floats_equalish(tests[i].expect_sum, kbn_sum,
                                    128 * DBL_EPSILON, DBL_MIN));
    }
}

static void fn_kbn_sumf64v(NO_STATE)
{
    const struct {
        double values[16];
        size_t n_values;
        double expect_sum;
    } tests[] = {
        { { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 },
          12, 78.0 },
        { { 1.0, pow(10.0, 100.0), 1.0, -pow(10.0, 100.0) },
          4, 2.0 },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    unsigned i;

    for (i = 0; i < n_tests; i++) {
        double kbn_sum = kbn_sumf64v(tests[i].values, tests[i].n_values);
        double naive_sum = 0.0;
        unsigned j;
        const char *sep = "";

        if (verbose) {
            for (j = 0; j < tests[i].n_values; j++) {
                naive_sum += tests[i].values[j];
                printf("%s%.*g", sep, DBL_DECIMAL_DIG, tests[i].values[j]);
                sep = " + ";
            }
            printf(" = kbn: %.*g naive: %.*g expected: %.*g\n",
                   DBL_DECIMAL_DIG, kbn_sum,
                   DBL_DECIMAL_DIG, naive_sum,
                   DBL_DECIMAL_DIG, tests[i].expect_sum);
        }

        /* XXX assert_double_equal */
        assert_true(floats_equalish(tests[i].expect_sum, kbn_sum,
                                    128 * DBL_EPSILON, DBL_MIN));
    }
}

static void fn_niceceil(NO_STATE)
{
    const struct {
        double input;
        double expect;
    } tests[] = {
        {       0.0,          0.0    },
        {       0.0034,       0.0035 },
        {       0.4,          0.4    },
        {       0.41,         0.45   },
        {       1.2,          1.5    },
        {   84554.0,      85000.0    },
        {  143928.0,     150000.0    },
        { -143928.0,    -100000.0    },
        {  -84554.0,     -80000.0    },
        {      -1.2,         -1.0    },
        {      -0.41,        -0.40   },
        {      -0.4,         -0.4    },
        {      -0.0034,      -0.0030 },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    unsigned i;

    for (i = 0; i < n_tests; i++) {
        double actual = niceceil(tests[i].input);

        assert_float_equal(actual, tests[i].expect, TEST_EPSILON);
    }
}

static void fn_nicefloor(NO_STATE)
{
    const struct {
        double input;
        double expect;
    } tests[] = {
        {       0.0,          0.0    },
        {       0.0034,       0.0030 },
        {       0.4,          0.4    },
        {       0.41,         0.40   },
        {       1.2,          1.0    },
        {   84554.0,      80000.0    },
        {  143928.0,     100000.0    },
        { -143928.0,    -150000.0    },
        {  -84554.0,     -85000.0    },
        {      -1.2,         -1.5    },
        {      -0.41,        -0.45   },
        {      -0.4,         -0.4    },
        {      -0.0034,      -0.0035 },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    unsigned i;

    for (i = 0; i < n_tests; i++) {
        double actual = nicefloor(tests[i].input);

        assert_float_equal(actual, tests[i].expect, TEST_EPSILON);
    }
}

const char *const um_group_name = "fputil";
const struct CMUnitTest um_group_tests[] =
{
    cmocka_unit_test(fn_kbn_sumf32v),
    cmocka_unit_test(fn_kbn_sumf64v),
    cmocka_unit_test(fn_niceceil),
    cmocka_unit_test(fn_nicefloor),
};
const size_t um_group_n_tests = sizeof(um_group_tests)
                                / sizeof(um_group_tests[0]);
CMFixtureFunction um_group_setup = NULL;
CMFixtureFunction um_group_teardown = NULL;

/* vim: set ft=c :*/
