#include "test/unitmain.h"

#include "src/hashmap.c"

#include <stdlib.h>

#define SENTINEL ((void *) 0xdeadbeef)

static int noop_destructor_called = 0;

static void noop_destructor(void *p __attribute__((unused)))
{
    noop_destructor_called ++;
}

static void assert_hashmap_invariants(const HashMap *hm)
{
    uint32_t i;
    uint32_t count, deleted;

    assert_ptr_equal(0, (uintptr_t) hm & 63u);

    if (!hm->alloc) {
        assert_null(hm->kmeta);
        assert_null(hm->key);
        assert_null(hm->value);
        assert_int_equal(0, hm->mask);
        assert_int_equal(0, hm->count);
        assert_int_equal(0, hm->deleted);
        assert_int_equal(0, hm->seed);
        assert_int_equal(0, hm->grow_threshold);
        assert_int_equal(0, hm->shrink_threshold);
        assert_int_equal(0, hm->gc_threshold);
        return;
    }

    assert_non_null(hm->kmeta);
    assert_non_null(hm->key);
    assert_non_null(hm->value);

    assert_in_range(hm->alloc, HASHMAP_MIN_SIZE, HASHMAP_MAX_SIZE);
    assert_int_equal(1, __builtin_popcount(hm->alloc));
    assert_int_equal(hm->mask, hm->alloc - 1);
    assert_in_range(hm->count + hm->deleted, 0, hm->alloc);

    if (hm->grow_threshold != HASHMAP_NO_GROW)
        assert_in_range(hm->grow_threshold, hm->alloc / 2, hm->alloc - 1);

    if (hm->alloc == HASHMAP_MIN_SIZE)
        assert_int_equal(HASHMAP_NO_SHRINK, hm->shrink_threshold);

    if (hm->shrink_threshold != HASHMAP_NO_SHRINK)
        assert_in_range(hm->shrink_threshold, 3, (hm->grow_threshold / 2) - 1);

    if (hm->gc_threshold != HASHMAP_NO_GC)
        assert_in_range(hm->gc_threshold, hm->alloc / 2, hm->alloc - 1);

    count = deleted = 0;
    for (i = 0; i < hm->alloc; i++) {
        if (hm->kmeta[i].deleted) {
            deleted ++;
            assert_int_equal(HASHMAP_BUCKET_EMPTY, hm->kmeta[i].len);
            assert_int_equal(0, hm->kmeta[i].hash);
            assert_null(hm->key[i].kptr);
            assert_null(hm->value[i]);
        }
        else if (hm->kmeta[i].len == HASHMAP_BUCKET_EMPTY) {
            assert_int_equal(0, hm->kmeta[i].hash);
            assert_null(hm->key[i].kptr);
            assert_null(hm->value[i]);
        }
        else {
            count ++;
            assert_non_null(hm->key[i].kptr);
        }
    }
    assert_int_equal(count, hm->count);
    assert_int_equal(deleted, hm->deleted);
}

static int cmp_uint32_t(const void *a, const void *b)
{
    const uint32_t *aa = a, *bb = b;

    return (aa > bb) - (aa < bb);
}

static void fn_hashmap_hash32(NO_STATE)
{
    const struct {
        char key[16];
        unsigned len;
    } tests[] = {
        { "dogaaaaaaaaaaaa", 0 },
        { "cataaaaaaaaaaaa", 0 },
        { "foo",             0 },
        { "foo\0bar",        7 },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    uint32_t actual[n_tests];
    unsigned i;

    for (i = 0; i < n_tests; i++) {
        uint32_t diff_seed;
        unsigned len;

        /* use strlen when len is zero */
        len = tests[i].len ? tests[i].len : strlen(tests[i].key);

        actual[i] = hashmap_hash32(tests[i].key, len, 0);
        diff_seed = hashmap_hash32(tests[i].key, len, 23);

        /* different seed -> different hash */
        assert_int_not_equal(diff_seed, actual[i]);
    }

    /* no collisions in this set */
    qsort(actual, n_tests, sizeof(actual[0]), &cmp_uint32_t);
    for (i = 1; i < n_tests; i++) {
        assert_int_not_equal(actual[i - 1], actual[i]);
    }
}

static void fn_hashmap_strerr(NO_STATE)
{
    const struct {
        int r;
        const char *expect_s;
    } tests[] = {
        { HASHMAP_E_NOKEY,      "key not found" },
        { HASHMAP_E_KEYTOOBIG,  "key too long" },
        { HASHMAP_E_REHASH,     "map is full" },
        { HASHMAP_E_NOMEM,      "memory allocation failed" },
        { HASHMAP_E_INVALID,    "invalid argument" },
        { HASHMAP_E_UNKNOWN,    "unknown error" },
        { HASHMAP_OK,           "ok" },
        { 69,                   "unrecognised error code 69" },
        { -1,                   "unrecognised error code -1" },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    unsigned i;

    for (i = 0; i < n_tests; i++) {
        const char *s = hashmap_strerr(tests[i].r);
        assert_string_equal(tests[i].expect_s, s);
    }
}

static void init_fini(NO_STATE)
{
    const struct {
        uint32_t init_size;
        int      expect_r;
        uint32_t expect_alloc;
    } tests[] = {
        {                    0, HASHMAP_OK,     HASHMAP_MIN_SIZE },
        { HASHMAP_MIN_SIZE - 1, HASHMAP_OK,     HASHMAP_MIN_SIZE },
        {     HASHMAP_MIN_SIZE, HASHMAP_OK,     HASHMAP_MIN_SIZE },
        { HASHMAP_MIN_SIZE + 1, HASHMAP_OK, 2 * HASHMAP_MIN_SIZE },
        {                   42, HASHMAP_OK,                   64 },
        {                65536, HASHMAP_OK,                65536 },
        {               100000, HASHMAP_OK,           128 * 1024 },
        {              1000000, HASHMAP_OK,          1024 * 1024 },
        {            100000000, HASHMAP_OK,    128 * 1024 * 1024 },
        { HASHMAP_MAX_SIZE + 1, HASHMAP_E_INVALID,             0 },
        {           UINT32_MAX, HASHMAP_E_INVALID,             0 },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    bool have_prev_seed = false;
    uint32_t prev_seed = 0;
    HashMap hm;
    unsigned i;
    int r;

    for (i = 0; i < n_tests; i++) {
        r = hashmap_init(&hm, tests[i].init_size);

        if (r == HASHMAP_E_NOMEM) {
            assert_int_equal(0, hm.alloc);
            assert_hashmap_invariants(&hm);
        }
        else {
            assert_int_equal(tests[i].expect_r, r);
            assert_int_equal(tests[i].expect_alloc, hm.alloc);
            assert_hashmap_invariants(&hm);

            if (r == HASHMAP_OK) {
                if (have_prev_seed)
                    assert_int_not_equal(prev_seed, hm.seed);
                prev_seed = hm.seed;
                have_prev_seed = true;

                noop_destructor_called = 0;
                hashmap_fini(&hm, &noop_destructor);
                assert_int_equal(0, noop_destructor_called);

                assert_hashmap_invariants(&hm);
            }
        }
    }
}

static void get_basic(NO_STATE)
{
    HashMap hm;
    const char key[] = "velvet", long_key[] = "extraterrestrial";
    void *value = SENTINEL;
    int r;

    hashmap_init(&hm, 0);

    /* get a key that doesn't exist, don't care about value */
    r = hashmap_get(&hm, key, strlen(key), NULL);
    assert_int_equal(HASHMAP_E_NOKEY, r);

    /* get a key that doesn't exist */
    r = hashmap_get(&hm, key, strlen(key), &value);
    assert_int_equal(HASHMAP_E_NOKEY, r);
    assert_null(value);

    /* get a key that does exist with null value */
    r = hashmap_put(&hm, key, strlen(key), NULL, NULL);
    assert_int_equal(HASHMAP_OK, r);
    assert_hashmap_invariants(&hm);
    value = SENTINEL;
    r = hashmap_get(&hm, key, strlen(key), &value);
    assert_int_equal(HASHMAP_OK, r);
    assert_null(value);

    /* get a key that does exist with value */
    r = hashmap_put(&hm, key, strlen(key), (void *) 12, NULL);
    assert_int_equal(HASHMAP_OK, r);
    assert_hashmap_invariants(&hm);
    r = hashmap_get(&hm, key, strlen(key), &value);
    assert_int_equal(HASHMAP_OK, r);
    assert_ptr_equal((void *) 12, value);

    /* get a key that does exist, don't care about value */
    r = hashmap_get(&hm, key, strlen(key), NULL);
    assert_int_equal(HASHMAP_OK, r);

    /* get a key that was deleted */
    r = hashmap_del(&hm, key, strlen(key), &value);
    assert_int_equal(HASHMAP_OK, r);
    assert_ptr_equal((void *) 12, value);
    assert_hashmap_invariants(&hm);
    r = hashmap_get(&hm, key, strlen(key), &value);
    assert_int_equal(HASHMAP_E_NOKEY, r);
    assert_null(value);

    /* get a long key that doesn't exist */
    r = hashmap_get(&hm, long_key, strlen(long_key), &value);
    assert_int_equal(HASHMAP_E_NOKEY, r);
    assert_null(value);

    /* get a long key that does exist */
    r = hashmap_put(&hm, long_key, strlen(long_key), (void *) 12, NULL);
    assert_int_equal(HASHMAP_OK, r);
    r = hashmap_get(&hm, long_key, strlen(long_key), &value);
    assert_int_equal(HASHMAP_OK, r);
    assert_ptr_equal((void *) 12, value);

    hashmap_fini(&hm, NULL);
}

static void do_put_del(const char *const keys[], size_t n_keys, uint32_t seed)
{
    uint32_t expect_alloc = HASHMAP_MIN_SIZE;
    uint32_t expect_count = 0, expect_deleted = 0;
    HashMap hm;
    unsigned i;
    int r;

    assert(n_keys == 8);

    hashmap_init(&hm, 0);
    hm.seed = seed;

    assert_int_equal(expect_alloc, hm.alloc);
    assert_int_equal(expect_count, hm.count);
    assert_int_equal(expect_deleted, hm.deleted);

    /* insert the first half */
    for (i = 0; i < n_keys / 2; i++) {
        void *old_value = SENTINEL;

        expect_count ++;

        r = hashmap_put(&hm,
                        keys[i],
                        strlen(keys[i]),
                        (void *)(uintptr_t) i,
                        &old_value);
        assert_int_equal(HASHMAP_OK, r);
        assert_null(old_value);

        assert_int_equal(expect_alloc, hm.alloc);
        assert_int_equal(expect_count, hm.count);
        assert_int_equal(expect_deleted, hm.deleted);
        assert_hashmap_invariants(&hm);
    }

    /* delete a couple */
    for (i = 0; i < 2; i++) {
        void *old_value = SENTINEL;

        expect_count --;
        expect_deleted ++;

        r = hashmap_del(&hm, keys[i], strlen(keys[i]),
                        &old_value);
        assert_int_equal(HASHMAP_OK, r);
        assert_ptr_equal(i, old_value);

        assert_int_equal(expect_alloc, hm.alloc);
        assert_int_equal(expect_count, hm.count);
        assert_int_equal(expect_deleted, hm.deleted);
        assert_hashmap_invariants(&hm);
    }

    /* delete the same two again, they shouldn't exist */
    for (i = 0; i < 2; i++) {
        void *old_value = SENTINEL;

        r = hashmap_del(&hm, keys[i], strlen(keys[i]),
                        &old_value);
        assert_int_equal(HASHMAP_E_NOKEY, r);
        assert_null(old_value);

        assert_int_equal(expect_alloc, hm.alloc);
        assert_int_equal(expect_count, hm.count);
        assert_int_equal(expect_deleted, hm.deleted);
        assert_hashmap_invariants(&hm);
    }

    /* reinsert, expect them to reuse the deleted slots */
    for (i = 0; i < 2; i++) {
        void *old_value = SENTINEL;

        expect_count ++;
        expect_deleted --;

        r = hashmap_put(&hm,
                        keys[i],
                        strlen(keys[i]),
                        (void *)(uintptr_t) i,
                        &old_value);
        assert_int_equal(HASHMAP_OK, r);
        assert_null(old_value);

        assert_int_equal(expect_alloc, hm.alloc);
        assert_int_equal(expect_count, hm.count);
        assert_int_equal(expect_deleted, hm.deleted);
        assert_hashmap_invariants(&hm);
    }

    /* insert the rest, expect to grow */
    for (i = n_keys / 2; i < n_keys; i++) {
        void *old_value = SENTINEL;

        if (should_grow(&hm, hm.count))
            expect_alloc *= 2;
        expect_count ++;

        r = hashmap_put(&hm,
                        keys[i],
                        strlen(keys[i]),
                        (void *)(uintptr_t) i,
                        &old_value);
        assert_int_equal(HASHMAP_OK, r);
        assert_null(old_value);

        assert_int_equal(expect_alloc, hm.alloc);
        assert_int_equal(expect_count, hm.count);
        assert_int_equal(expect_deleted, hm.deleted);
        assert_hashmap_invariants(&hm);
    }

    /* insert them all again with the same value as before */
    for (i = 0; i < n_keys; i++) {
        void *old_value = SENTINEL;

        r = hashmap_put(&hm,
                        keys[i],
                        strlen(keys[i]),
                        (void *)(uintptr_t) i,
                        &old_value);
        assert_int_equal(HASHMAP_OK, r);
        assert_null(old_value);

        assert_int_equal(expect_alloc, hm.alloc);
        assert_int_equal(expect_count, hm.count);
        assert_int_equal(expect_deleted, hm.deleted);
        assert_hashmap_invariants(&hm);
    }

    /* insert them all again with a new value */
    for (i = 0; i < n_keys; i++) {
        void *old_value = SENTINEL;

        r = hashmap_put(&hm,
                        keys[i],
                        strlen(keys[i]),
                        (void *)(uintptr_t) (i & 0x80000000),
                        &old_value);
        assert_int_equal(HASHMAP_OK, r);
        assert_ptr_equal(i, old_value);

        assert_int_equal(expect_alloc, hm.alloc);
        assert_int_equal(expect_count, hm.count);
        assert_int_equal(expect_deleted, hm.deleted);
        assert_hashmap_invariants(&hm);
    }

    /* delete them all, don't care about value */
    for (i = 0; i < n_keys; i++) {
        if (should_shrink(&hm, hm.count - 1)) {
            expect_alloc /= 2;
            expect_deleted = 0;
        }
        else if (should_gc(&hm, hm.count - 1, hm.deleted + 1)) {
            expect_deleted = 0;
        }
        else {
            expect_deleted ++;
        }
        expect_count --;

        r = hashmap_del(&hm,
                        keys[i],
                        strlen(keys[i]),
                        NULL);
        assert_int_equal(HASHMAP_OK, r);

        assert_int_equal(expect_alloc, hm.alloc);
        assert_int_equal(expect_count, hm.count);
        assert_int_equal(expect_deleted, hm.deleted);
        assert_hashmap_invariants(&hm);
    }

    hashmap_fini(&hm, NULL);
}

static void put_del_nocollide(NO_STATE)
{
    /* keys that do not collide when mask is 0x7 and seed is 5 */
    const char *const keys[] = {
        "moline",
        "urn",
        "consistent",
        "fluctuate",
        "Meath",
        "eider",
        "villain",
        "Lowell",
    };
    const size_t n_keys = sizeof(keys) / sizeof(keys[0]);
    static_assert(n_keys == 8);
    const uint32_t seed = 5;
    const uint32_t mask = 0x00000007;
    uint32_t hash[n_keys];
    unsigned i;

    /* validate belief that these keys do not collide */
    for (i = 0; i < n_keys; i++) {
        hash[i] = hashmap_hash32(keys[i], strlen(keys[i]), seed) & mask;
    }
    qsort(hash, n_keys, sizeof(hash[0]), &cmp_uint32_t);
    for (i = 1; i < n_keys; i++)
        assert_int_not_equal(hash[i - 1], hash[i]);

    do_put_del(keys, n_keys, seed);
}

static void put_del_collide(NO_STATE)
{
    /* keys that collide (hash=0x3a) when mask is 0xff and seed is 5.
     * "ember" and "equiv" have the same hash (0x1c12fb3a) even unmasked,
     * and the same length, to force a real key comparison
     */
    const char *const keys[] = {
        "pronouncing",
        "cupcake",
        "furies",
        "lived",
        "ember",
        "equiv",
        "Appenzell",
        "rabbinical",
    };
    const size_t n_keys = sizeof(keys) / sizeof(keys[0]);
    const uint32_t seed = 5;
    const uint32_t mask = 0x000000ff;
    static_assert(n_keys == 8);
    uint32_t h, i, x;

    /* validate belief that these keys collide */
    for (i = 0; i < n_keys; i++) {
        x = hashmap_hash32(keys[i],
                           strlen(keys[i]),
                           seed);
        if (i > 0)
            assert_int_equal((h & mask), (x & mask));
        h = x;
    }

    do_put_del(keys, n_keys, seed);
}

static void full(NO_STATE)
{
    const char *const keys[] = {
        "inalterable",
        "babu",
        "overstate",
        "Asperges",
        "disendow",
        "Kishinev",
        "mesic",
        "Flamsteed",
        "lymphangitis",
        "same",
        "disulfiram",
        "overland",
        "osculate",
        "broccoli",
        "compassionate",
        "decisive",
        "athwart",
        "otolith",
        "diuretic",
        "quadrature",
    };
    const size_t n_keys = sizeof(keys) / sizeof(keys[0]);
    HashMap hm;
    uint32_t expect_alloc, expect_count, expect_deleted;
    uint32_t index;
    void *value;
    unsigned i;
    int r;

    static_assert(n_keys >= 2 * HASHMAP_MIN_SIZE);

    hashmap_init(&hm, 0);
    hm.grow_threshold = HASHMAP_NO_GROW;
    expect_alloc = HASHMAP_MIN_SIZE;
    expect_count = expect_deleted = 0;

    for (i = 0; i < HASHMAP_MIN_SIZE; i++) {
        expect_count ++;

        r = hashmap_put(&hm, keys[i], strlen(keys[i]),
                        (void *)(uintptr_t) i, NULL);
        assert_int_equal(HASHMAP_OK, r);

        assert_int_equal(expect_alloc, hm.alloc);
        assert_int_equal(expect_count, hm.count);
        assert_int_equal(expect_deleted, hm.deleted);
        assert_hashmap_invariants(&hm);
    }

    for (i = 0; i < HASHMAP_MIN_SIZE; i++) {
        r = find(&hm, 0, keys[i], strlen(keys[i]), NULL, &index);
        assert_int_equal(HASHMAP_OK, r);
        assert_in_range(index, 0, HASHMAP_MIN_SIZE);
    }

    for (; i < 2 * HASHMAP_MIN_SIZE; i++) {
        r = find(&hm, 0, keys[i], strlen(keys[i]), NULL, &index);
        assert_int_equal(HASHMAP_E_REHASH, r);
        assert_int_equal(UINT32_MAX, index);

        value = SENTINEL;
        r = hashmap_get(&hm, keys[i], strlen(keys[i]), &value);
        assert_int_equal(HASHMAP_E_NOKEY, r);
        assert_null(value);

        value = SENTINEL;
        r = hashmap_del(&hm, keys[i], strlen(keys[i]), &value);
        assert_int_equal(HASHMAP_E_NOKEY, r);
        assert_null(value);
    }

    /* from full, the first few deletions should gc each time */
    for (i = 0; i < 4; i++) {
        expect_count --;
        expect_deleted = 0;

        value = SENTINEL;
        r = hashmap_del(&hm, keys[i], strlen(keys[i]), &value);
        assert_int_equal(HASHMAP_OK, r);
        assert_ptr_equal(i, value);

        assert_int_equal(expect_alloc, hm.alloc);
        assert_int_equal(expect_count, hm.count);
        assert_int_equal(expect_deleted, hm.deleted);
        assert_hashmap_invariants(&hm);
    }

    /* the next should leave tombstones */
    for (; i < HASHMAP_MIN_SIZE; i++) {
        expect_count --;
        expect_deleted ++;

        value = SENTINEL;
        r = hashmap_del(&hm, keys[i], strlen(keys[i]), &value);
        assert_int_equal(HASHMAP_OK, r);
        assert_ptr_equal(i, value);

        assert_int_equal(expect_alloc, hm.alloc);
        assert_int_equal(expect_count, hm.count);
        assert_int_equal(expect_deleted, hm.deleted);
        assert_hashmap_invariants(&hm);

        r = find(&hm, 0, keys[i], strlen(keys[i]), NULL, &index);
        assert_int_equal(HASHMAP_E_NOKEY, r);
        assert_int_equal(1, hm.kmeta[index].deleted);
    }

    /* fill it back up */
    expect_count = HASHMAP_MIN_SIZE;
    expect_deleted = 0;
    i = HASHMAP_MIN_SIZE;
    do {
        r = hashmap_put(&hm, keys[i], strlen(keys[i]),
                        (void *)(uintptr_t) i, NULL);

        i++;
    } while (i < n_keys && r == HASHMAP_OK);

    assert_int_equal(HASHMAP_E_REHASH, r);

    assert_int_equal(expect_alloc, hm.alloc);
    assert_int_equal(expect_count, hm.count);
    assert_int_equal(expect_deleted, hm.deleted);
    assert_hashmap_invariants(&hm);

    hashmap_fini(&hm, NULL);
}

const char *const um_group_name = "hashmap";
const struct CMUnitTest um_group_tests[] =
{
    cmocka_unit_test(fn_hashmap_hash32),
    cmocka_unit_test(fn_hashmap_strerr),
    cmocka_unit_test(init_fini),
    cmocka_unit_test(get_basic),
    cmocka_unit_test(put_del_nocollide),
    cmocka_unit_test(put_del_collide),
    cmocka_unit_test(full),
};
const size_t um_group_n_tests = sizeof(um_group_tests)
                                / sizeof(um_group_tests[0]);
CMFixtureFunction um_group_setup = NULL;
CMFixtureFunction um_group_teardown = NULL;

/* vim: set ft=c :*/
