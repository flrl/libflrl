#include "test/unitmain.h"

#include "src/hashmap.c"

#include "flrl/randutil.h"
#include "flrl/xoshiro.h"

#include <profileapi.h> /* win32 */

#include <stdio.h>
#include <stdlib.h>

#define SENTINEL ((void *) 0xdeadbeef)

static int noop_destructor_called = 0;

static void noop_destructor(void *p __attribute__((unused)))
{
    noop_destructor_called ++;
}

static void dump_hashmap_stats(const HashMap *hm)
{
    HashMapStats stats;

    hashmap_get_stats(hm, &stats);

    fprintf(stderr, "%" PRIu32 " + %" PRIu32 " / %" PRIu32 " buckets in use\n",
                    hm->count, hm->deleted, hm->alloc);
    fprintf(stderr, "load factor: %g\n", stats.load);
    fprintf(stderr, "psl min: %" PRIu32 " (%g)\n",
                    stats.psl.min, 1.0 * stats.psl.min_frequency / hm->count);
    fprintf(stderr, "psl max: %" PRIu32 " (%g)\n",
                    stats.psl.max, 1.0 * stats.psl.max_frequency / hm->count);
    fprintf(stderr, "psl mean: %g\n", stats.psl.mean);
    fprintf(stderr, "psl median: %g\n", stats.psl.median);
    fprintf(stderr, "psl mode: %" PRIu32 " (%g)\n",
                    stats.psl.mode, 1.0 * stats.psl.mode_frequency / hm->count);
    fprintf(stderr, "psl stddev: %g\n", sqrt(stats.psl.variance));
    fprintf(stderr, "bdc min: %" PRIu32 " (%g)\n",
                    stats.bdc.min, 1.0 * stats.bdc.min_frequency / hm->alloc);
    fprintf(stderr, "bdc max: %" PRIu32 " (%g)\n",
                    stats.bdc.max, 1.0 * stats.bdc.max_frequency / hm->alloc);
    fprintf(stderr, "bdc mean: %g\n", stats.bdc.mean);
    fprintf(stderr, "bdc median: %g\n", stats.bdc.median);
    fprintf(stderr, "bdc mode: %" PRIu32 " (%g)\n",
                    stats.bdc.mode, 1.0 * stats.bdc.mode_frequency / hm->alloc);
    fprintf(stderr, "bdc stddev: %g\n", sqrt(stats.bdc.variance));
}

__attribute__((unused))
static void dump_hashmap(const HashMap *hm)
{
    uint32_t i, mask;

    mask = hm->alloc - 1;

    dump_hashmap_stats(hm);

    for (i = 0; i < hm->alloc; i++) {
        const char *key;
        int key_len;

        switch (hm->key[i].len) {
        case HASHMAP_BUCKET_EMPTY:
            key = "EMPTY";
            key_len = 5;
            break;
        case HASHMAP_BUCKET_DELETED:
            key = "DELETED";
            key_len = 7;
            break;
        default:
            key = HM_KEY(hm, i);
            key_len = hm->key[i].len;
            break;
        }

        fprintf(stderr, "%u: key=%.*s hash=%u want=%u psl=%u\n",
                        i, key_len, key,
                        hm->key[i].hash, (hm->key[i].hash & mask),
                        HM_PSL(hm, i));
    }
}

static void assert_hashmap_invariants(const HashMap *hm)
{
    uint32_t i;
    uint32_t count, empty, deleted;
    uint32_t mask = hm->alloc - 1;

    assert_ptr_equal(0, (uintptr_t) hm & 63u);

    if (!hm->alloc) {
        assert_null(hm->key);
        assert_null(hm->value);
        assert_int_equal(0, hm->count);
        assert_int_equal(0, hm->deleted);
        assert_int_equal(0, hm->seed);
        assert_int_equal(0, hm->grow_threshold);
        assert_int_equal(0, hm->shrink_threshold);
        assert_int_equal(0, hm->gc_threshold);
        return;
    }

    assert_non_null(hm->key);
    assert_non_null(hm->value);

    assert_in_range(hm->alloc, HASHMAP_MIN_SIZE, HASHMAP_MAX_SIZE);
    assert_int_equal(1, __builtin_popcount(hm->alloc));
    assert_in_range(hm->count + hm->deleted, 0, hm->alloc);

    if (hm->grow_threshold != HASHMAP_NO_GROW)
        assert_in_range(hm->grow_threshold, hm->alloc / 2, hm->alloc - 1);

    if (hm->alloc == HASHMAP_MIN_SIZE)
        assert_int_equal(HASHMAP_NO_SHRINK, hm->shrink_threshold);

    if (hm->shrink_threshold != HASHMAP_NO_SHRINK)
        assert_in_range(hm->shrink_threshold, 3, (hm->grow_threshold / 2) - 1);

    if (hm->gc_threshold != HASHMAP_NO_GC)
        assert_in_range(hm->gc_threshold, hm->alloc / 2, hm->alloc - 1);

    count = empty = deleted = 0;
    for (i = 0; i < hm->alloc; i++) {
        if (hm->key[i].len == HASHMAP_BUCKET_DELETED) {
            deleted ++;
            assert_null(hm->key[i].kptr);
            assert_null(hm->value[i]);
        }
        else if (hm->key[i].len == HASHMAP_BUCKET_EMPTY) {
            empty ++;
            assert_int_equal(0, hm->key[i].hash);
            assert_null(hm->key[i].kptr);
            assert_null(hm->value[i]);
        }
        else {
            uint32_t prev_i, psl, prev_psl;

            count ++;

            assert_non_null(hm->key[i].kptr);
            assert_int_equal(true, has_key_at_index(hm, i));

            prev_i = (hm->alloc + i - 1) & mask;
            if (hm->key[prev_i].len != HASHMAP_BUCKET_EMPTY) {
                psl = HM_PSL(hm, i);
                prev_psl = HM_PSL(hm, prev_i);
                if (psl > prev_psl) {
                    assert_int_equal(hm->key[i].hash & mask,
                                     hm->key[prev_i].hash & mask);
                }
                else {
                    assert_int_not_equal(hm->key[i].hash & mask,
                                         hm->key[prev_i].hash & mask);
                }
            }
        }
    }
    assert_int_equal(count + empty + deleted, hm->alloc);
    assert_int_equal(count, hm->count);
    assert_int_equal(deleted, hm->deleted);

    assert_float_in_range(1.0 * hm->count / hm->alloc, 0.0, 1.0);
}

__attribute__((unused))
static const char *random_printable(struct randbs *rbs)
{
    static char word[16];
    unsigned len;

    len = randu32(rbs, 6, sizeof(word) - 1);
    randi8v(rbs, (int8_t *) word, len, ' ', '~');
    word[len] = '\0';

    return word;
}

static int cmp_uint32_t(const void *a, const void *b)
{
    const uint32_t *aa = a, *bb = b;

    return (aa > bb) - (aa < bb);
}

static void fn_hashmap_hash32(NO_STATE)
{
    const struct {
        char key[16];
        unsigned len;
    } tests[] = {
        { "dogaaaaaaaaaaaa", 0 },
        { "cataaaaaaaaaaaa", 0 },
        { "foo",             0 },
        { "foo\0bar",        7 },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    uint32_t actual[n_tests];
    unsigned i;

    for (i = 0; i < n_tests; i++) {
        uint32_t diff_seed;
        unsigned len;

        /* use strlen when len is zero */
        len = tests[i].len ? tests[i].len : strlen(tests[i].key);

        actual[i] = hashmap_hash32(tests[i].key, len, 0);
        diff_seed = hashmap_hash32(tests[i].key, len, 23);

        /* different seed -> different hash */
        assert_int_not_equal(diff_seed, actual[i]);
    }

    /* no collisions in this set */
    qsort(actual, n_tests, sizeof(actual[0]), &cmp_uint32_t);
    for (i = 1; i < n_tests; i++) {
        assert_int_not_equal(actual[i - 1], actual[i]);
    }
}

static void fn_hashmap_strerr(NO_STATE)
{
    const struct {
        int r;
        const char *expect_s;
    } tests[] = {
        { HASHMAP_E_NOKEY,      "key not found" },
        { HASHMAP_E_KEYTOOBIG,  "key too long" },
        { HASHMAP_E_REHASH,     "map is full" },
        { HASHMAP_E_NOMEM,      "memory allocation failed" },
        { HASHMAP_E_INVALID,    "invalid argument" },
        { HASHMAP_E_UNKNOWN,    "unknown error" },
        { HASHMAP_OK,           "ok" },
        { 69,                   "unrecognised error code 69" },
        { -1,                   "unrecognised error code -1" },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    unsigned i;

    for (i = 0; i < n_tests; i++) {
        const char *s = hashmap_strerr(tests[i].r);
        assert_string_equal(tests[i].expect_s, s);
    }
}

static void init_fini(NO_STATE)
{
    const struct {
        uint32_t init_size;
        int      expect_r;
        uint32_t expect_alloc;
    } tests[] = {
        {                    0, HASHMAP_OK,     HASHMAP_MIN_SIZE },
        { HASHMAP_MIN_SIZE - 1, HASHMAP_OK,     HASHMAP_MIN_SIZE },
        {     HASHMAP_MIN_SIZE, HASHMAP_OK,     HASHMAP_MIN_SIZE },
        { HASHMAP_MIN_SIZE + 1, HASHMAP_OK, 2 * HASHMAP_MIN_SIZE },
        {                   42, HASHMAP_OK,                   64 },
        {                65536, HASHMAP_OK,                65536 },
        {               100000, HASHMAP_OK,           128 * 1024 },
        {              1000000, HASHMAP_OK,          1024 * 1024 },
        {            100000000, HASHMAP_OK,    128 * 1024 * 1024 },
        { HASHMAP_MAX_SIZE + 1, HASHMAP_E_INVALID,             0 },
        {           UINT32_MAX, HASHMAP_E_INVALID,             0 },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    bool have_prev_seed = false;
    uint32_t prev_seed = 0;
    HashMap hm;
    unsigned i;
    int r;

    for (i = 0; i < n_tests; i++) {
        r = hashmap_init(&hm, tests[i].init_size);

        if (r == HASHMAP_E_NOMEM) {
            assert_int_equal(0, hm.alloc);
            assert_hashmap_invariants(&hm);
        }
        else {
            assert_int_equal(tests[i].expect_r, r);
            assert_int_equal(tests[i].expect_alloc, hm.alloc);
            assert_hashmap_invariants(&hm);

            if (r == HASHMAP_OK) {
                if (have_prev_seed)
                    assert_int_not_equal(prev_seed, hm.seed);
                prev_seed = hm.seed;
                have_prev_seed = true;

                noop_destructor_called = 0;
                hashmap_fini(&hm, &noop_destructor);
                assert_int_equal(0, noop_destructor_called);

                assert_hashmap_invariants(&hm);
            }
        }
    }
}

static void get_basic(NO_STATE)
{
    HashMap hm;
    const char key[] = "velvet", long_key[] = "extraterrestrial";
    void *value = SENTINEL;
    int r;

    hashmap_init(&hm, 0);

    /* get a key that doesn't exist, don't care about value */
    r = hashmap_get(&hm, key, strlen(key), NULL);
    assert_int_equal(HASHMAP_E_NOKEY, r);

    /* get a key that doesn't exist */
    r = hashmap_get(&hm, key, strlen(key), &value);
    assert_int_equal(HASHMAP_E_NOKEY, r);
    assert_null(value);

    /* get a key that does exist with null value */
    r = hashmap_put(&hm, key, strlen(key), NULL, NULL);
    assert_int_equal(HASHMAP_OK, r);
    assert_hashmap_invariants(&hm);
    value = SENTINEL;
    r = hashmap_get(&hm, key, strlen(key), &value);
    assert_int_equal(HASHMAP_OK, r);
    assert_null(value);

    /* get a key that does exist with value */
    r = hashmap_put(&hm, key, strlen(key), (void *) 12, NULL);
    assert_int_equal(HASHMAP_OK, r);
    assert_hashmap_invariants(&hm);
    r = hashmap_get(&hm, key, strlen(key), &value);
    assert_int_equal(HASHMAP_OK, r);
    assert_ptr_equal((void *) 12, value);

    /* get a key that does exist, don't care about value */
    r = hashmap_get(&hm, key, strlen(key), NULL);
    assert_int_equal(HASHMAP_OK, r);

    /* get a key that was deleted */
    r = hashmap_del(&hm, key, strlen(key), &value);
    assert_int_equal(HASHMAP_OK, r);
    assert_ptr_equal((void *) 12, value);
    assert_hashmap_invariants(&hm);
    r = hashmap_get(&hm, key, strlen(key), &value);
    assert_int_equal(HASHMAP_E_NOKEY, r);
    assert_null(value);

    /* get a long key that doesn't exist */
    r = hashmap_get(&hm, long_key, strlen(long_key), &value);
    assert_int_equal(HASHMAP_E_NOKEY, r);
    assert_null(value);

    /* get a long key that does exist */
    r = hashmap_put(&hm, long_key, strlen(long_key), (void *) 12, NULL);
    assert_int_equal(HASHMAP_OK, r);
    r = hashmap_get(&hm, long_key, strlen(long_key), &value);
    assert_int_equal(HASHMAP_OK, r);
    assert_ptr_equal((void *) 12, value);

    hashmap_fini(&hm, NULL);
}

static void do_put_del(const char *const keys[], size_t n_keys, uint32_t seed)
{
    uint32_t expect_alloc = HASHMAP_MIN_SIZE;
    uint32_t expect_count = 0, expect_deleted = 0;
    HashMap hm;
    unsigned i;
    int r;

    assert(n_keys == 8);

    hashmap_init(&hm, 0);
    hm.seed = seed;

    assert_int_equal(expect_alloc, hm.alloc);
    assert_int_equal(expect_count, hm.count);
    assert_int_equal(expect_deleted, hm.deleted);

    /* insert the first half */
    for (i = 0; i < n_keys / 2; i++) {
        void *old_value = SENTINEL;

        expect_count ++;

        r = hashmap_put(&hm,
                        keys[i],
                        strlen(keys[i]),
                        (void *)(uintptr_t) i,
                        &old_value);
        assert_int_equal(HASHMAP_OK, r);
        assert_null(old_value);

        assert_int_equal(expect_alloc, hm.alloc);
        assert_int_equal(expect_count, hm.count);
        assert_int_equal(expect_deleted, hm.deleted);
        assert_hashmap_invariants(&hm);
    }

    /* delete a couple */
    for (i = 0; i < 2; i++) {
        void *old_value = SENTINEL;

        expect_count --;
        expect_deleted ++;

        r = hashmap_del(&hm, keys[i], strlen(keys[i]),
                        &old_value);
        assert_int_equal(HASHMAP_OK, r);
        assert_ptr_equal(i, old_value);

        assert_int_equal(expect_alloc, hm.alloc);
        assert_int_equal(expect_count, hm.count);
        assert_int_equal(expect_deleted, hm.deleted);
        assert_hashmap_invariants(&hm);
    }

    /* delete the same two again, they shouldn't exist */
    for (i = 0; i < 2; i++) {
        void *old_value = SENTINEL;

        r = hashmap_del(&hm, keys[i], strlen(keys[i]),
                        &old_value);
        assert_int_equal(HASHMAP_E_NOKEY, r);
        assert_null(old_value);

        assert_int_equal(expect_alloc, hm.alloc);
        assert_int_equal(expect_count, hm.count);
        assert_int_equal(expect_deleted, hm.deleted);
        assert_hashmap_invariants(&hm);
    }

    /* reinsert, expect them to reuse the deleted slots */
    for (i = 0; i < 2; i++) {
        void *old_value = SENTINEL;

        expect_count ++;
        expect_deleted --;

        r = hashmap_put(&hm,
                        keys[i],
                        strlen(keys[i]),
                        (void *)(uintptr_t) i,
                        &old_value);
        assert_int_equal(HASHMAP_OK, r);
        assert_null(old_value);

        assert_int_equal(expect_alloc, hm.alloc);
        assert_int_equal(expect_count, hm.count);
        assert_int_equal(expect_deleted, hm.deleted);
        assert_hashmap_invariants(&hm);
    }

    /* insert the rest, expect to grow */
    for (i = n_keys / 2; i < n_keys; i++) {
        void *old_value = SENTINEL;

        if (should_grow(&hm, hm.count))
            expect_alloc *= 2;
        expect_count ++;

        r = hashmap_put(&hm,
                        keys[i],
                        strlen(keys[i]),
                        (void *)(uintptr_t) i,
                        &old_value);
        assert_int_equal(HASHMAP_OK, r);
        assert_null(old_value);

        assert_int_equal(expect_alloc, hm.alloc);
        assert_int_equal(expect_count, hm.count);
        assert_int_equal(expect_deleted, hm.deleted);
        assert_hashmap_invariants(&hm);
    }

    /* insert them all again with the same value as before */
    for (i = 0; i < n_keys; i++) {
        void *old_value = SENTINEL;

        r = hashmap_put(&hm,
                        keys[i],
                        strlen(keys[i]),
                        (void *)(uintptr_t) i,
                        &old_value);
        assert_int_equal(HASHMAP_OK, r);
        assert_null(old_value);

        assert_int_equal(expect_alloc, hm.alloc);
        assert_int_equal(expect_count, hm.count);
        assert_int_equal(expect_deleted, hm.deleted);
        assert_hashmap_invariants(&hm);
    }

    /* insert them all again with a new value */
    for (i = 0; i < n_keys; i++) {
        void *old_value = SENTINEL;

        r = hashmap_put(&hm,
                        keys[i],
                        strlen(keys[i]),
                        (void *)(uintptr_t) (i & 0x80000000),
                        &old_value);
        assert_int_equal(HASHMAP_OK, r);
        assert_ptr_equal(i, old_value);

        assert_int_equal(expect_alloc, hm.alloc);
        assert_int_equal(expect_count, hm.count);
        assert_int_equal(expect_deleted, hm.deleted);
        assert_hashmap_invariants(&hm);
    }

    /* delete them all, don't care about value */
    for (i = 0; i < n_keys; i++) {
        if (should_shrink(&hm, hm.count - 1)) {
            expect_alloc /= 2;
            expect_deleted = 0;
        }
        else if (should_gc(&hm, hm.count - 1, hm.deleted + 1)) {
            expect_deleted = 0;
        }
        else {
            expect_deleted ++;
        }
        expect_count --;

        r = hashmap_del(&hm,
                        keys[i],
                        strlen(keys[i]),
                        NULL);
        assert_int_equal(HASHMAP_OK, r);

        assert_int_equal(expect_alloc, hm.alloc);
        assert_int_equal(expect_count, hm.count);
        assert_int_equal(expect_deleted, hm.deleted);
        assert_hashmap_invariants(&hm);
    }

    hashmap_fini(&hm, NULL);
}

static void put_del_nocollide(NO_STATE)
{
    /* keys that do not collide when mask is 0x7 and seed is 5 */
    const char *const keys[] = {
        "moline",
        "urn",
        "consistent",
        "fluctuate",
        "Meath",
        "eider",
        "villain",
        "Lowell",
    };
    const size_t n_keys = sizeof(keys) / sizeof(keys[0]);
    static_assert(sizeof(keys) / sizeof(keys[0]) == 8);
    const uint32_t seed = 5;
    const uint32_t mask = 0x00000007;
    uint32_t hash[n_keys];
    unsigned i;

    /* validate belief that these keys do not collide */
    for (i = 0; i < n_keys; i++) {
        hash[i] = hashmap_hash32(keys[i], strlen(keys[i]), seed) & mask;
    }
    qsort(hash, n_keys, sizeof(hash[0]), &cmp_uint32_t);
    for (i = 1; i < n_keys; i++)
        assert_int_not_equal(hash[i - 1], hash[i]);

    do_put_del(keys, n_keys, seed);
}

static void put_del_collide(NO_STATE)
{
    /* keys that collide (hash=0x3a) when mask is 0xff and seed is 5.
     * "ember" and "equiv" have the same hash (0x1c12fb3a) even unmasked,
     * and the same length, to force a real key comparison
     */
    const char *const keys[] = {
        "pronouncing",
        "cupcake",
        "furies",
        "lived",
        "ember",
        "equiv",
        "Appenzell",
        "rabbinical",
    };
    const size_t n_keys = sizeof(keys) / sizeof(keys[0]);
    static_assert(sizeof(keys) / sizeof(keys[0]) == 8);
    const uint32_t seed = 5;
    const uint32_t mask = 0x000000ff;
    uint32_t h, i, x;

    /* validate belief that these keys collide */
    for (i = 0; i < n_keys; i++) {
        x = hashmap_hash32(keys[i],
                           strlen(keys[i]),
                           seed);
        if (i > 0)
            assert_int_equal((h & mask), (x & mask));
        h = x;
    }

    do_put_del(keys, n_keys, seed);
}

static void full(NO_STATE)
{
    const char *const keys[] = {
        "inalterable",
        "babu",
        "overstate",
        "Asperges",
        "disendow",
        "Kishinev",
        "mesic",
        "Flamsteed",
        "lymphangitis",
        "same",
        "disulfiram",
        "overland",
        "osculate",
        "broccoli",
        "compassionate",
        "decisive",
        "athwart",
        "otolith",
        "diuretic",
        "quadrature",
    };
    const size_t n_keys = sizeof(keys) / sizeof(keys[0]);
    static_assert(sizeof(keys) / sizeof(keys[0]) >= 2 * HASHMAP_MIN_SIZE);
    HashMap hm;
    uint32_t expect_alloc, expect_count, expect_deleted;
    uint32_t index;
    void *value;
    unsigned i;
    int r;

    hashmap_init(&hm, 0);
    hm.grow_threshold = HASHMAP_NO_GROW;
    expect_alloc = HASHMAP_MIN_SIZE;
    expect_count = expect_deleted = 0;

    /* insert until full */
    for (i = 0; i < HASHMAP_MIN_SIZE; i++) {
        expect_count ++;

        r = hashmap_put(&hm, keys[i], strlen(keys[i]),
                        (void *)(uintptr_t) i, NULL);
        assert_int_equal(HASHMAP_OK, r);

        assert_int_equal(expect_alloc, hm.alloc);
        assert_int_equal(expect_count, hm.count);
        assert_int_equal(expect_deleted, hm.deleted);
        assert_hashmap_invariants(&hm);
    }

    /* look up keys we know are in there */
    for (i = 0; i < HASHMAP_MIN_SIZE; i++) {
        r = find(&hm, 0, keys[i], strlen(keys[i]), NULL, &index);
        assert_int_equal(HASHMAP_OK, r);
        assert_in_range(index, 0, HASHMAP_MIN_SIZE);
    }

    /* look up keys we know are not in there */
    for (; i < 2 * HASHMAP_MIN_SIZE; i++) {
        r = find(&hm, 0, keys[i], strlen(keys[i]), NULL, &index);
        assert_int_equal(HASHMAP_E_NOKEY, r);
        assert_in_range(index, 0, expect_alloc - 1);

        value = SENTINEL;
        r = hashmap_get(&hm, keys[i], strlen(keys[i]), &value);
        assert_int_equal(HASHMAP_E_NOKEY, r);
        assert_null(value);

        value = SENTINEL;
        r = hashmap_del(&hm, keys[i], strlen(keys[i]), &value);
        assert_int_equal(HASHMAP_E_NOKEY, r);
        assert_null(value);
    }

    /* from full, the first few deletions should gc each time */
    for (i = 0; i < 4; i++) {
        expect_count --;
        expect_deleted = 0;

        value = SENTINEL;
        r = hashmap_del(&hm, keys[i], strlen(keys[i]), &value);
        assert_int_equal(HASHMAP_OK, r);
        assert_ptr_equal(i, value);

        assert_int_equal(expect_alloc, hm.alloc);
        assert_int_equal(expect_count, hm.count);
        assert_int_equal(expect_deleted, hm.deleted);
        assert_hashmap_invariants(&hm);
    }

    /* the next should leave tombstones */
    for (; i < HASHMAP_MIN_SIZE; i++) {
        expect_count --;
        expect_deleted ++;

        value = SENTINEL;
        r = hashmap_del(&hm, keys[i], strlen(keys[i]), &value);
        assert_int_equal(HASHMAP_OK, r);
        assert_ptr_equal(i, value);

        assert_int_equal(expect_alloc, hm.alloc);
        assert_int_equal(expect_count, hm.count);
        assert_int_equal(expect_deleted, hm.deleted);
        assert_hashmap_invariants(&hm);

        r = find(&hm, 0, keys[i], strlen(keys[i]), NULL, &index);
        assert_int_equal(HASHMAP_E_NOKEY, r);
        assert_int_equal(HASHMAP_BUCKET_DELETED, hm.key[index].len);
    }

    /* fill it back up */
    expect_count = HASHMAP_MIN_SIZE;
    expect_deleted = 0;
    i = HASHMAP_MIN_SIZE;
    do {
        r = hashmap_put(&hm, keys[i], strlen(keys[i]),
                        (void *)(uintptr_t) i, NULL);

        i++;
    } while (i < n_keys && r == HASHMAP_OK);

    assert_int_equal(HASHMAP_E_REHASH, r);

    assert_int_equal(expect_alloc, hm.alloc);
    assert_int_equal(expect_count, hm.count);
    assert_int_equal(expect_deleted, hm.deleted);
    assert_hashmap_invariants(&hm);

    hashmap_fini(&hm, NULL);
}

static int foreach_cb(const HashMap *hm,
                      const void *key,
                      size_t key_len,
                      void *value,
                      void *ctx)
{
    unsigned *call_count = ctx;
    int r;
    void *check_value = SENTINEL;

    (*call_count) ++;

    r = hashmap_get(hm, key, key_len, &check_value);
    assert_int_equal(HASHMAP_OK, r);
    assert_ptr_equal(value, check_value);

    return 0;
}

static void fn_hashmap_foreach(NO_STATE)
{
    const struct  {
        const char *const key;
        uintptr_t value;
    } tests[] = {
        { "wat",               11 },
        { "Meanwhile",          4 },
        { "partial",            9 },
        { "afield",             1 },
        { "deservings",         6 },
        { "transformations",    1 },
        { "ELEANOR",           45 },
        { "gentlest",           2 },
        { "Rougemount",         1 },
        { "crown",            295 },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    unsigned i, cb_call_count = 0;
    HashMap hm;
    int r;

    hashmap_init(&hm, 0);

    for (i = 0; i < n_tests; i++) {
        r = hashmap_put(&hm, tests[i].key, strlen(tests[i].key),
                        (void *) tests[i].value, NULL);
    }

    r = hashmap_foreach(&hm, &foreach_cb, &cb_call_count);
    assert_int_equal(HASHMAP_OK, r);
    assert_int_equal(n_tests, cb_call_count);

    hashmap_fini(&hm, NULL);
}

static inline int64_t get_timestamp(void)
{
    LARGE_INTEGER tmp;
    QueryPerformanceCounter(&tmp);
    return tmp.QuadPart;
}

static void do_load_factor(double load_factor)
{
    HashMap hm;
    const unsigned size = 262144;
    const unsigned n_ops = 10000;
    struct randbs rbs = RANDBS_INITIALIZER(xoshiro128starstar_next);
    unsigned i, x, y;
    int r;

    assert(load_factor >= 0.5);
    assert(load_factor <= 1.0);

    hashmap_init(&hm, size);
    hm.grow_threshold = HASHMAP_NO_GROW;
    hm.shrink_threshold = HASHMAP_NO_SHRINK;
    hm.gc_threshold = HASHMAP_NO_GC;
    assert_int_equal(size, hm.alloc);

    randbs_seed64(&rbs, 0xcafebabefeeddeed); /* XXX need variable but repeatable seeds */

    /* fill up to load factor */
    for (i = 0; i < load_factor * size; i++) {
        const char *word = random_printable(&rbs);
//         uint32_t key = randu32(&rbs, 0, UINT32_MAX);
        r = hashmap_put(&hm, word, strlen(word), (void *)(uintptr_t) i, NULL);
        assert_int_equal(HASHMAP_OK, r);
    }
    dump_hashmap_stats(&hm);
    assert_hashmap_invariants(&hm);

    /* alternating random operations */
    for (i = x = y = 0; i < n_ops; i++) {
        const void *key;
        size_t key_len;
        uint32_t x;

        switch ((i & 3)) {
        case 0:
            /* insert a random new (probably) key */
            key = random_printable(&rbs);
            key_len = strlen((const char *) key);

            r = hashmap_put(&hm, key, key_len, (void *)(uintptr_t) i, NULL);

            assert_int_equal(HASHMAP_OK, r);
            break;
        case 1:
            /* delete a random existing key */
            x = randu32(&rbs, 0, hm.alloc - 1);

            while (!has_key_at_index(&hm, x))
                x = (x + 1) & (hm.alloc - 1);

            key = HM_KEY(&hm, x);
            key_len = hm.key[x].len;

            r = hashmap_del(&hm, key, key_len, NULL);

            assert_int_equal(HASHMAP_OK, r);
            break;
        case 2:
            /* get a random existing key */
            x = randu32(&rbs, 0, hm.alloc - 1);

            while (!has_key_at_index(&hm, x))
                x = (x + 1) & (hm.alloc - 1);

            key = HM_KEY(&hm, x);
            key_len = hm.key[x].len;

            r = hashmap_get(&hm, key, key_len, NULL);

            assert_int_equal(HASHMAP_OK, r);
            break;
        case 3:
            /* get a random probably nonexistent key */
            key = random_printable(&rbs);
            key_len = strlen((const char *) key);

            r = hashmap_get(&hm, key, key_len, NULL);

            break;
        }
    }

    dump_hashmap_stats(&hm);
    assert_hashmap_invariants(&hm);

    hashmap_fini(&hm, NULL);
}

static void load_factor_60(NO_STATE)
{
    do_load_factor(0.6);
}

static void load_factor_70(NO_STATE)
{
    do_load_factor(0.7);
}

static void load_factor_80(NO_STATE)
{
    do_load_factor(0.8);
}

static void load_factor_90(NO_STATE)
{
    do_load_factor(0.90);
}

static void load_factor_91(NO_STATE)
{
    do_load_factor(0.91);
}

static void load_factor_92(NO_STATE)
{
    do_load_factor(0.92);
}

static void load_factor_93(NO_STATE)
{
    do_load_factor(0.93);
}

static void load_factor_94(NO_STATE)
{
    do_load_factor(0.94);
}

static void load_factor_95(NO_STATE)
{
    do_load_factor(0.95);
}

static void load_factor_96(NO_STATE)
{
    do_load_factor(0.96);
}

static void load_factor_97(NO_STATE)
{
    do_load_factor(0.97);
}

static void load_factor_98(NO_STATE)
{
    do_load_factor(0.98);
}

static void load_factor_99(NO_STATE)
{
    do_load_factor(0.99);
}

const char *const um_group_name = "hashmap";
const struct CMUnitTest um_group_tests[] =
{
    cmocka_unit_test(fn_hashmap_hash32),
    cmocka_unit_test(fn_hashmap_strerr),
    cmocka_unit_test(init_fini),
    cmocka_unit_test(get_basic),
    cmocka_unit_test(put_del_nocollide),
    cmocka_unit_test(put_del_collide),
    cmocka_unit_test(full),
    cmocka_unit_test(fn_hashmap_foreach),
    cmocka_unit_test(load_factor_60),
    cmocka_unit_test(load_factor_70),
    cmocka_unit_test(load_factor_80),
    cmocka_unit_test(load_factor_90),
    cmocka_unit_test(load_factor_91),
    cmocka_unit_test(load_factor_92),
    cmocka_unit_test(load_factor_93),
    cmocka_unit_test(load_factor_94),
    cmocka_unit_test(load_factor_95),
    cmocka_unit_test(load_factor_96),
    cmocka_unit_test(load_factor_97),
    cmocka_unit_test(load_factor_98),
    cmocka_unit_test(load_factor_99),
};
const size_t um_group_n_tests = sizeof(um_group_tests)
                                / sizeof(um_group_tests[0]);
CMFixtureFunction um_group_setup = NULL;
CMFixtureFunction um_group_teardown = NULL;

/* vim: set ft=c :*/
