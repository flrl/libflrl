#include "test/unitmain.h"

#include "src/randutil.c"

#include "flrl/fputil.h"
#include "flrl/xoshiro.h"

#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <time.h>

/* testing the interfaces/distributions, not the underlying randomness */
#define N_VALUES (10000)

static const uint32_t seed128[4] = {
    0x26457b9d,
    0x9c2fdf6b,
    0xd9cdfc7b,
    0x6dc7cdbd,
};

struct mock_rng32_state {
    union {
        struct {
            uint32_t *outputs;
            uint16_t next_index;
            uint16_t call_count;
            uint16_t n_outputs;
        } m;
        struct state128 s;
    };
};
static_assert(sizeof(struct mock_rng32_state) == sizeof(struct state128));

static uint32_t mock_rng32(struct state128 *statep)
{
    struct mock_rng32_state *state = (struct mock_rng32_state *) statep;
    uint32_t val;

    if (!state->m.n_outputs) abort();

    state->m.call_count ++;

    val = state->m.outputs[state->m.next_index ++];

    if (state->m.next_index >= state->m.n_outputs)
        state->m.next_index = 0;

    return val;
}

static void setup_mock_bs(struct randbs *bs,
                          struct mock_rng32_state **state,
                          const struct mock_rng32_state *init)
{
    memset(bs, 0, sizeof(*bs));
    memcpy(&bs->rng.state, init, sizeof(*init));
    bs->rng.func = mock_rng32;
    *state = (struct mock_rng32_state *) &bs->rng.state;
}

static unsigned bit_width(uint64_t i)
{
    return i > 0 ? 64 - __builtin_clzll(i) : 0;
}

static void fn_randbs_bits(NO_STATE)
{
    const struct mock_rng32_state rng_init = {
        .m.outputs = (uint32_t[]) {
            0b01010101101010100011001111001100,
            0b00001111111100000000000011111111,
            0b01010101101010100011001111001100,
            0b11110000111100001111000011110000,
            0b11110000111100001111000011110000,
            0b11110000111100001111000011110000,
            0b11111111000000001111111100000000,
            0b11111111000000001111111100000000,
        },
        .m.n_outputs = 8,
    };
    const struct {
        unsigned want_bits;
        uint64_t expect_bits;
    } tests[] = {
        {  0, 0b0 },
        {  1, 0b0 },
        {  2, 0b10 },
        {  3, 0b001 },
        {  4, 0b1111 },
        {  5, 0b01100 },
        {  6, 0b010100 },
        {  7, 0b0101101 },
        {  8, 0b11110101 },
        {  9, 0b000001111 },
        { 10, 0b1110000000 },
        { 11, 0b00000011111 },
        { 12, 0b110011110011 },
        { 13, 0b1011010101000 },
        {  5, 0b01010 },
        { 33, 0b011110000111100001111000011110000 },
        { 47, 0b11110000111100001111000011110000111100001111000 },
        { 64, 0b1111111100000000111111110000000011111111000000001111000011110000 },
        { 14, 0b11111100000000 },
        {  2, 0b11 },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    struct randbs bs;
    struct mock_rng32_state *rng_state;
    unsigned i;

    setup_mock_bs(&bs, &rng_state, &rng_init);

    for (i = 0; i < n_tests; i++) {
        uint64_t v = randbs_bits(&bs, tests[i].want_bits);
        assert_int_equal(tests[i].expect_bits, v);
    }

    assert_int_equal(rng_state->m.call_count, rng_state->m.n_outputs);
}

static void fn_randbs_zeroes(NO_STATE)
{
    const struct mock_rng32_state rng_init = {
        .m.outputs = (uint32_t[]) {
            0b00000110000000010000000100000010,
            0b11000000000000000000000000000010,
            0b00000000000000000000000000000001,
            0b10000000000000000110000000000000,
            0b00000000000000000000000000000000,
            0b00000000000000000000000000000000,
            0b00000000000000000000000000001000,
            0b00000000000000000000000000000000,
            0b10000000000000000000000000000000,
        },
        .m.n_outputs = 9,
    };
    const struct {
        unsigned limit;
        unsigned expect_zeroes;
        uint32_t expect_call_count;
    } tests[] = {
        {  7,  1, 1 },
        {  7,  6, 1 },
        {  7,  7, 1 },
        {  7,  0, 1 },
        {  7,  7, 1 },
        {  7,  1, 1 },
        {  7,  0, 1 },
        {  7,  6, 2 },
        { 15, 15, 2 },
        { 15, 13, 2 },
        { 15,  0, 2 },
        { 15,  0, 3 },
        { 15, 15, 3 },
        { 15, 15, 3 },
        { 15, 14, 4 },
        { 15,  0, 4 },
        { 15, 15, 4 },
        { 15,  1, 4 },
        { 80, 67, 7 },
        { 64, 64, 9 },
        { 32, 27, 9 },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    struct randbs bs;
    struct mock_rng32_state *rng_state;
    unsigned i;

    setup_mock_bs(&bs, &rng_state, &rng_init);

    for (i = 0; i < n_tests; i++) {
        unsigned zeroes = randbs_zeroes(&bs, tests[i].limit);

        assert_int_equal(tests[i].expect_zeroes, zeroes);
        assert_int_equal(tests[i].expect_call_count, rng_state->m.call_count);
    }
}

static void randi32v_range(NO_STATE)
{
    const struct {
        int32_t min;
        int32_t max;
    } tests[] = {
        {         0,         0 },
        {         0,         1 },
        {         1,         0 },
        {        -1,         1 },
        {       -10,         0 },
        {      -100,       -10 },
        {         1,        10 },
        {        10,       100 },
        {      -100,       100 },
        { INT32_MIN, INT32_MAX },
        { INT32_MIN,         0 },
        {         0, INT32_MAX },
        { INT32_MIN, INT32_MIN },
        { INT32_MAX, INT32_MAX },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    const size_t n_values = N_VALUES;
    struct randbs bs = RANDBS_INITIALIZER(RNG_INIT_XOSHIRO128_PLUSPLUS);
    int32_t *values;
    unsigned i;

    randbs_seed(&bs, seed128, sizeof(seed128));

    values = calloc(n_values, sizeof(values[0]));
    assert_non_null(values);

    for (i = 0; i < n_tests; i++) {
        int32_t expect_min = tests[i].min;
        int32_t expect_max = tests[i].max;
        int32_t largest = INT32_MIN, smallest = INT32_MAX;
        unsigned j;

        if (expect_min > expect_max) expect_min = expect_max;

        randi32v(&bs, values, n_values, tests[i].min, tests[i].max);

        for (j = 0; j < n_values; j++) {
            if (values[j] > largest) largest = values[j];
            if (values[j] < smallest) smallest = values[j];
            assert_int_in_range(values[j], expect_min, expect_max);
        }

        if (expect_min != expect_max && n_values > 10)
            assert_int_not_equal(smallest, largest);
    }

    free(values);
}

static void randi32v_call_count(NO_STATE)
{
    const struct mock_rng32_state rng_init = {
        .m.outputs = (uint32_t[]) {
            0b00000100000100000100001000100101,
            0b00010000000001000000001000000010,
            0b00000000000010000000000010000000,
            0b00100000000000000100000000000001,
        },
        .m.n_outputs = 4,
    };
    const struct {
        size_t n_values;
        int32_t min;
        int32_t max;
    } tests[] = {
        { 10,         0,         1 },
        { 10,         0,        20 },
        { 10,         0,     65535 },
        { 10,         0,     65536 },
        { 10,         0,     65537 },
        { 10, INT32_MIN, INT32_MAX },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    struct randbs bs;
    struct mock_rng32_state *rng_state;
    int32_t *values;
    unsigned i;

    setup_mock_bs(&bs, &rng_state, &rng_init);

    for (i = 0; i < n_tests; i++) {
        uint32_t range = tests[i].max - tests[i].min;
        unsigned min_call_count = bit_width(range) * tests[i].n_values / 32;

        values = calloc(tests[i].n_values, sizeof(values[0]));

        rng_state->m.call_count = 0;
        randi32v(&bs, values, tests[i].n_values, tests[i].min, tests[i].max);

        assert_in_range(rng_state->m.call_count,
                        min_call_count,
                        tests[i].n_values);

        free(values);
    }
}

static void randu32v_range(NO_STATE)
{
    const struct {
        uint32_t min;
        uint32_t max;
    } tests[] = {
        {          0,          0 },
        {          0,          1 },
        {          1,          0 },
        {          1,         10 },
        {         10,        100 },
        {          0, UINT32_MAX },
        { UINT32_MAX,          0 },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    const size_t n_values = N_VALUES;
    struct randbs bs = RANDBS_INITIALIZER(RNG_INIT_XOSHIRO128_PLUSPLUS);
    uint32_t *values;
    unsigned i;

    randbs_seed(&bs, seed128, sizeof(seed128));

    values = calloc(n_values, sizeof(values[0]));
    assert_non_null(values);

    for (i = 0; i < n_tests; i++) {
        uint32_t expect_min = tests[i].min;
        uint32_t expect_max = tests[i].max;
        uint32_t largest = 0, smallest = UINT32_MAX;
        unsigned j;

        if (expect_min > expect_max) expect_min = expect_max;

        randu32v(&bs, values, n_values, tests[i].min, tests[i].max);

        for (j = 0; j < n_values; j++) {
            if (values[j] > largest) largest = values[j];
            if (values[j] < smallest) smallest = values[j];
            assert_int_in_range(values[j], expect_min, expect_max);
        }

        if (expect_min != expect_max && n_values > 10)
            assert_int_not_equal(smallest, largest);
    }

    free(values);
}

static void randu32v_call_count(NO_STATE)
{
    const struct mock_rng32_state rng_init = {
        .m.outputs = (uint32_t[]) {
            0b00000100000100000100001000100101,
            0b00010000000001000000001000000010,
            0b00000000000010000000000010000000,
            0b00100000000000000100000000000001,
        },
        .m.n_outputs = 4,
    };
    const struct {
        size_t n_values;
        uint32_t min;
        uint32_t max;
    } tests[] = {
        { 10, 0,          1 },
        { 10, 0,         20 },
        { 10, 0,      65535 },
        { 10, 0,      65536 },
        { 10, 0,      65537 },
        { 10, 0, UINT32_MAX },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    struct randbs bs;
    struct mock_rng32_state *rng_state;
    uint32_t *values;
    unsigned i;

    setup_mock_bs(&bs, &rng_state, &rng_init);

    for (i = 0; i < n_tests; i++) {
        uint32_t range = tests[i].max - tests[i].min;
        unsigned min_call_count = bit_width(range) * tests[i].n_values / 32;

        values = calloc(tests[i].n_values, sizeof(values[0]));

        rng_state->m.call_count = 0;
        randu32v(&bs, values, tests[i].n_values, tests[i].min, tests[i].max);

        assert_in_range(rng_state->m.call_count,
                        min_call_count,
                        tests[i].n_values);

        free(values);
    }
}

static void randf32v_range(NO_STATE)
{
    const struct {
        double min;
        double max;
    } tests[] = {
        {      0.0,     1.0 },
        {  FLT_MIN,     1.0 },
        {     -0.5,     0.5 },
        {     -1.0,     1.0 },
        {     -2.0,    -1.0 },
        { -FLT_MAX,     0.0 },
//         { -FLT_MAX, FLT_MAX }, /* XXX overflows range */
        {      0.0, FLT_MAX },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    const size_t n_values = N_VALUES;
    struct randbs bs = RANDBS_INITIALIZER(RNG_INIT_XOSHIRO128_PLUSPLUS);
    float *values;
    unsigned i;

    randbs_seed(&bs, seed128, sizeof(seed128));

    values = calloc(n_values, sizeof(values[0]));
    assert_non_null(values);

    for (i = 0; i < n_tests; i++) {
        float expect_min = tests[i].min;
        float expect_max = tests[i].max;
        float largest = -INFINITY, smallest = INFINITY;
        unsigned j;

        if (expect_min > expect_max) expect_min = expect_max;

        randf32v(&bs, values, n_values, tests[i].min, tests[i].max);

        for (j = 0; j < n_values; j++) {
            if (values[j] > largest) largest = values[j];
            if (values[j] < smallest) smallest = values[j];

            assert_float_in_range(values[j], expect_min, expect_max);
        }

        if (expect_min != expect_max && n_values > 10)
            assert_float_not_equal(smallest, largest, FLT_EPSILON);
    }

    free(values);
}

static void randf32v_chi2(NO_STATE)
{
    const struct {
        double min;
        double max;
    } tests[] = {
        {      0.0,     1.0 },
        {  FLT_MIN,     1.0 },
        {     -0.5,     0.5 },
        {     -1.0,     1.0 },
        {     -2.0,    -1.0 },
        { -FLT_MAX,     0.0 },
        {      0.0, FLT_MAX },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    const size_t n_values = 1000000;
    const size_t n_buckets = 16;
    const double bucket_p = 1.0 / n_buckets;
    /* from table: 15 dof at p=0.995, p=0.005 */
    const double critical_value[] = { 4.601, 32.801 };
    struct randbs bs = RANDBS_INITIALIZER(RNG_INIT_XOSHIRO128_PLUSPLUS);
    unsigned *bucket;
    double *bucket_t, *deviation;
    float *values;
    unsigned i;

    randbs_seed(&bs, seed128, sizeof(seed128));

    values = calloc(n_values, sizeof(values[0]));
    bucket = calloc(n_buckets, sizeof(bucket[0]));
    bucket_t = calloc(n_buckets, sizeof(bucket_t[0]));
    deviation = calloc(n_buckets, sizeof(deviation[0]));

    assert_true(values && bucket);

    for (i = 0; i < n_tests; i++) {
        const double range = (tests[i].max - tests[i].min) / n_buckets;
        double chi2;
        unsigned j;

        randf32v(&bs, values, n_values, tests[i].min, tests[i].max);

        memset(bucket_t, 0, n_buckets * sizeof(bucket_t[0]));
        for (j = 0; j < n_buckets; j++) {
            bucket_t[j] = fma(j + 1.0, range, tests[i].min);
        }

        memset(bucket, 0, n_buckets * sizeof(bucket[0]));
        for (j = 0; j < n_values; j++) {
            unsigned b;

            /* no buckets for out-of-range values */
            assert_float_in_range(values[j], tests[i].min, tests[i].max);

            for (b = 0; b < n_buckets; b++) {
                if (values[j] < bucket_t[b]) {
                    bucket[b] ++;
                    break;
                }
            }
        }

        memset(deviation, 0, n_buckets * sizeof(deviation[0]));
        for (j = 0; j < n_buckets; j++) {
            double e = bucket_p * n_values;
            double x = bucket[j] - e;
            deviation[j] = x * x / e;
        }
        chi2 = kbn_sumf64v(deviation, n_buckets);
        assert_float_in_range(chi2, critical_value[0], critical_value[1]);
    }

    free(deviation);
    free(bucket_t);
    free(bucket);
    free(values);
}

static void randi64v_range(NO_STATE)
{
    const struct {
        int64_t min;
        int64_t max;
    } tests[] = {
        {         0,         0 },
        {         0,         1 },
        {         1,         0 },
        {        -1,         1 },
        {       -10,         0 },
        {      -100,       -10 },
        {         1,        10 },
        {        10,       100 },
        {      -100,       100 },
        { INT32_MIN, INT32_MAX },
        { INT32_MIN,         0 },
        {         0, INT32_MAX },
        { INT32_MIN, INT32_MIN },
        { INT32_MAX, INT32_MAX },
        { INT64_MIN, INT64_MAX },
        { INT64_MIN,         0 },
        {         0, INT64_MAX },
        { INT64_MIN, INT64_MIN },
        { INT64_MAX, INT64_MAX },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    const size_t n_values = N_VALUES;
    struct randbs bs = RANDBS_INITIALIZER(RNG_INIT_XOSHIRO128_PLUSPLUS);
    int64_t *values;
    unsigned i;

    randbs_seed(&bs, seed128, sizeof(seed128));

    values = calloc(n_values, sizeof(values[0]));
    assert_non_null(values);

    for (i = 0; i < n_tests; i++) {
        int64_t expect_min = tests[i].min;
        int64_t expect_max = tests[i].max;
        int64_t largest = INT64_MIN, smallest = INT64_MAX;
        unsigned j;

        if (expect_min > expect_max) expect_min = expect_max;

        randi64v(&bs, values, n_values, tests[i].min, tests[i].max);

        for (j = 0; j < n_values; j++) {
            if (values[j] > largest) largest = values[j];
            if (values[j] < smallest) smallest = values[j];
            assert_int_in_range(values[j], expect_min, expect_max);
        }

        if (expect_min != expect_max && n_values > 10)
            assert_int_not_equal(smallest, largest);
    }

    free(values);
}

static void randi64v_call_count(NO_STATE)
{
    const struct mock_rng32_state rng_init = {
        .m.outputs = (uint32_t[]) {
            0b00000100000100000100001000100101,
            0b00010000000001000000001000000010,
            0b00000000000010000000000010000000,
            0b00100000000000000100000000000001,
        },
        .m.n_outputs = 4,
    };
    const struct {
        size_t n_values;
        int64_t min;
        int64_t max;
    } tests[] = {
        { 10,         0,         1 },
        { 10,         0,        20 },
        { 10,         0,     65535 },
        { 10,         0,     65536 },
        { 10,         0,     65537 },
        { 10, INT64_MIN, INT64_MAX },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    struct randbs bs;
    struct mock_rng32_state *rng_state;
    int64_t *values;
    unsigned i;

    setup_mock_bs(&bs, &rng_state, &rng_init);

    for (i = 0; i < n_tests; i++) {
        uint64_t range = tests[i].max - tests[i].min;
        unsigned min_call_count = bit_width(range) * tests[i].n_values / 32;

        values = calloc(tests[i].n_values, sizeof(values[0]));

        rng_state->m.call_count = 0;
        randi64v(&bs, values, tests[i].n_values, tests[i].min, tests[i].max);

        assert_in_range(rng_state->m.call_count,
                        min_call_count,
                        2 * tests[i].n_values);

        free(values);
    }
}

static void randu64v_range(NO_STATE)
{
    const struct {
        uint64_t min;
        uint64_t max;
    } tests[] = {
        {          0,          0 },
        {          0,          1 },
        {          1,          0 },
        {          1,         10 },
        {         10,        100 },
        {          0, UINT32_MAX },
        { UINT32_MAX,          0 },
        {          0, UINT64_MAX },
        { UINT64_MAX,          0 },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    const size_t n_values = N_VALUES;
    struct randbs bs = RANDBS_INITIALIZER(RNG_INIT_XOSHIRO128_PLUSPLUS);
    uint64_t *values;
    unsigned i;

    randbs_seed(&bs, seed128, sizeof(seed128));

    values = calloc(n_values, sizeof(values[0]));
    assert_non_null(values);

    for (i = 0; i < n_tests; i++) {
        uint64_t expect_min = tests[i].min;
        uint64_t expect_max = tests[i].max;
        uint64_t largest = 0, smallest = UINT64_MAX;
        unsigned j;

        if (expect_min > expect_max) expect_min = expect_max;

        randu64v(&bs, values, n_values, tests[i].min, tests[i].max);

        for (j = 0; j < n_values; j++) {
            if (values[j] > largest) largest = values[j];
            if (values[j] < smallest) smallest = values[j];
            assert_in_range(values[j], expect_min, expect_max);
        }

        if (expect_min != expect_max && n_values > 10)
            assert_int_not_equal(smallest, largest);
    }

    free(values);
}

static void randu64v_call_count(NO_STATE)
{
    const struct mock_rng32_state rng_init = {
        .m.outputs = (uint32_t[]) {
            0b00000100000100000100001000100101,
            0b00010000000001000000001000000010,
            0b00000000000010000000000010000000,
            0b00100000000000000100000000000001,
        },
        .m.n_outputs = 4,
    };
    const struct {
        size_t n_values;
        uint64_t min;
        uint64_t max;
    } tests[] = {
        { 10, 0,          1 },
        { 10, 0,         20 },
        { 10, 0,      65535 },
        { 10, 0,      65536 },
        { 10, 0,      65537 },
        { 10, 0, UINT64_MAX },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    struct randbs bs;
    struct mock_rng32_state *rng_state;
    uint64_t *values;
    unsigned i;

    setup_mock_bs(&bs, &rng_state, &rng_init);

    for (i = 0; i < n_tests; i++) {
        uint64_t range = tests[i].max - tests[i].min;
        unsigned min_call_count = bit_width(range) * tests[i].n_values / 32;

        values = calloc(tests[i].n_values, sizeof(values[0]));

        rng_state->m.call_count = 0;
        randu64v(&bs, values, tests[i].n_values, tests[i].min, tests[i].max);

        assert_in_range(rng_state->m.call_count,
                        min_call_count,
                        2 * tests[i].n_values);

        free(values);
    }
}

static void randf64v_range(NO_STATE)
{
    const struct {
        double min;
        double max;
    } tests[] = {
        {      0.0,     1.0 },
        {  DBL_MIN,     1.0 },
        {     -0.5,     0.5 },
        {     -1.0,     1.0 },
        {     -2.0,    -1.0 },
        { -DBL_MAX,     0.0 },
//         { -DBL_MAX, DBL_MAX }, /* XXX overflows range */
        {      0.0, DBL_MAX },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    const size_t n_values = N_VALUES;
    struct randbs bs = RANDBS_INITIALIZER(RNG_INIT_XOSHIRO128_PLUSPLUS);
    double *values;
    unsigned i;

    randbs_seed(&bs, seed128, sizeof(seed128));

    values = calloc(n_values, sizeof(values[0]));
    assert_non_null(values);

    for (i = 0; i < n_tests; i++) {
        double expect_min = tests[i].min;
        double expect_max = tests[i].max;
        double largest = -INFINITY, smallest = INFINITY;
        unsigned j;

        if (expect_min > expect_max) expect_min = expect_max;

        randf64v(&bs, values, n_values, tests[i].min, tests[i].max);

        for (j = 0; j < n_values; j++) {
            if (values[j] > largest) largest = values[j];
            if (values[j] < smallest) smallest = values[j];

            assert_float_in_range(values[j], expect_min, expect_max);
        }

        if (expect_min != expect_max && n_values > 10) {
            /* XXX assert_double_not_equal */
            assert_false(floats_equalish(smallest, largest,
                                         128 * DBL_EPSILON, DBL_MIN));
        }
    }

    free(values);
}

static void randf64v_chi2(NO_STATE)
{
    const struct {
        double min;
        double max;
    } tests[] = {
        {      0.0,     1.0 },
        {  DBL_MIN,     1.0 },
        {     -0.5,     0.5 },
        {     -1.0,     1.0 },
        {     -2.0,    -1.0 },
        { -DBL_MAX,     0.0 },
        {      0.0, DBL_MAX },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    const size_t n_values = 1000000;
    const size_t n_buckets = 16;
    const double bucket_p = 1.0 / n_buckets;
    /* from table: 15 dof at p=0.995, p=0.005 */
    const double critical_value[] = { 4.601, 32.801 };
    struct randbs bs = RANDBS_INITIALIZER(RNG_INIT_XOSHIRO128_PLUSPLUS);
    unsigned *bucket;
    double *bucket_t, *deviation;
    double *values;
    unsigned i;

    randbs_seed(&bs, seed128, sizeof(seed128));

    values = calloc(n_values, sizeof(values[0]));
    bucket = calloc(n_buckets, sizeof(bucket[0]));
    bucket_t = calloc(n_buckets, sizeof(bucket_t[0]));
    deviation = calloc(n_buckets, sizeof(deviation[0]));

    assert_true(values && bucket);

    for (i = 0; i < n_tests; i++) {
        const double range = (tests[i].max - tests[i].min) / n_buckets;
        double chi2;
        unsigned j;

        randf64v(&bs, values, n_values, tests[i].min, tests[i].max);

        memset(bucket_t, 0, n_buckets * sizeof(bucket_t[0]));
        for (j = 0; j < n_buckets; j++) {
            bucket_t[j] = fma(j + 1.0, range, tests[i].min);
        }

        memset(bucket, 0, n_buckets * sizeof(bucket[0]));
        for (j = 0; j < n_values; j++) {
            unsigned b;

            /* no buckets for out-of-range values */
            assert_float_in_range(values[j], tests[i].min, tests[i].max);

            for (b = 0; b < n_buckets; b++) {
                if (values[j] < bucket_t[b]) {
                    bucket[b] ++;
                    break;
                }
            }
        }

        memset(deviation, 0, n_buckets * sizeof(deviation[0]));
        for (j = 0; j < n_buckets; j++) {
            double e = bucket_p * n_values;
            double x = bucket[j] - e;
            deviation[j] = x * x / e;
        }
        chi2 = kbn_sumf64v(deviation, n_buckets);
        assert_float_in_range(chi2, critical_value[0], critical_value[1]);
    }

    free(deviation);
    free(bucket_t);
    free(bucket);
    free(values);
}


static void gaussf32v_gaussf32_same_seq(NO_STATE)
{
    const struct {
        double mean;
        double stddev;
    } tests[] = {
        { 0.0, 1.0 },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    const size_t n_values = N_VALUES;
    struct randbs bs = RANDBS_INITIALIZER(RNG_INIT_XOSHIRO128_PLUSPLUS);
    float *values;
    unsigned i;

    values = calloc(n_values, sizeof(values[0]));
    assert_non_null(values);

    for (i = 0; i < n_tests; i++) {
        unsigned j;

        bs.bits = bs.n_bits = 0;
        randbs_seed(&bs, seed128, sizeof(seed128));
        gaussf32v(&bs, values, n_values, tests[i].mean, tests[i].stddev);

        bs.bits = bs.n_bits = 0;
        randbs_seed(&bs, seed128, sizeof(seed128));
        for (j = 0; j < n_values; j++) {
            float v = gaussf32(&bs, tests[i].mean, tests[i].stddev);

            assert_float_equal(v, values[j], FLT_EPSILON);
        }
    }

    free(values);
}

static void gaussf32v_mean(NO_STATE)
{
    const struct {
        double mean;
        double stddev;
    } tests[] = {
        { 0.0, 1.0 },
        { 4.0, 3.0 },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    const size_t n_values = 1 << 20; /* about a million, as a power of two */
    const double recip_n_values = 1.0 / n_values;
    const double recip_sqrt_n_values = 1.0 / sqrt(n_values);
    struct randbs bs = RANDBS_INITIALIZER(RNG_INIT_XOSHIRO128_PLUSPLUS);
    float *values;
    unsigned i;

    randbs_seed64(&bs, time(NULL));

    values = calloc(n_values, sizeof(values[0]));
    assert_non_null(values);

    for (i = 0; i < n_tests; i++) {
        double mean, mean_stddev;

        gaussf32v(&bs, values, n_values, tests[i].mean, tests[i].stddev);
        mean = kbn_sumf32v(values, n_values) * recip_n_values;

        /* the standard deviation of the mean is smaller than the standard
         * deviation of individual samples by a factor of 1/sqrt(n)
         */
        mean_stddev = tests[i].stddev * recip_sqrt_n_values;

        /* should be within 2 standard deviations 95% of the time, and within
         * 3 standard deviations 99.7% of the time
         */
        assert_float_in_range(mean,
                              fma(-3.0, mean_stddev, tests[i].mean),
                              fma(3.0, mean_stddev, tests[i].mean));
    }

    free(values);
}

static void gaussf32v_variance(NO_STATE)
{
    const struct {
        double mean;
        double stddev;
    } tests[] = {
        {  0.0, 1.0 },
        { -2.0, 7.0 },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    const size_t n_values = 1 << 20; /* about a million, as a power of two */
    const double recip_n_values = 1.0 / n_values;
    struct randbs bs = RANDBS_INITIALIZER(RNG_INIT_XOSHIRO128_PLUSPLUS);
    float *values;
    unsigned i;

    randbs_seed64(&bs, time(NULL));

    values = calloc(n_values, sizeof(values[0]));
    assert_non_null(values);

    for (i = 0; i < n_tests; i++) {
        const double expected_variance = tests[i].stddev * tests[i].stddev;
        double mean, variance = 0.0, variance_stddev;
        unsigned j;

        gaussf32v(&bs, values, n_values, tests[i].mean, tests[i].stddev);
        mean = kbn_sumf32v(values, n_values) *recip_n_values;

        for (j = 0; j < n_values; j++) {
            double diff = values[j] - mean;

            /* n.b. using population variance rather than sample variance,
             * because x/n plays nicer with floating point than x/(n - 1)
             * when n is a power of 2
             */
            variance += diff * diff * recip_n_values;
        }

        /* sample variance approximately has a normal distribution with mean
         * of stddev^2 and variance of 2*stddev^4 / (n - 1)
         */
        variance_stddev = sqrt(2.0 * pow(tests[i].stddev, 4.0) * recip_n_values);
        assert_float_in_range(variance,
                              fma(-3.0, variance_stddev, expected_variance),
                              fma(3.0, variance_stddev, expected_variance));
    }

    free(values);
}

static void gaussf32v_chi2(NO_STATE)
{
    const struct {
        double mean;
        double stddev;
    } tests[] = {
        {  0.0, 1.0 },
        { -2.0, 7.0 },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    const size_t n_values = 1 << 20; /* about a million, as a power of two */
    const size_t n_buckets = 8;
    const double bucket_p[8] = { 0.00135, 0.0214, 0.1359, 0.34135,
                                 0.34135, 0.1359, 0.0214, 0.00135 };
    struct randbs bs = RANDBS_INITIALIZER(RNG_INIT_XOSHIRO128_PLUSPLUS);
    float *values;
    unsigned i;

    randbs_seed64(&bs, time(NULL));

    values = calloc(n_values, sizeof(values[0]));
    assert_non_null(values);

    for (i = 0; i < n_tests; i++) {
        double chi2 = 0.0;
        unsigned bucket[8] = { 0 };
        unsigned j;

        gaussf32v(&bs, values, n_values, tests[i].mean, tests[i].stddev);

        for (j = 0; j < n_values; j++) {
            if (values[j] < tests[i].mean - 3.0 * tests[i].stddev) {
                bucket[0] ++;
            }
            else if (values[j] < tests[i].mean - 2.0 * tests[i].stddev) {
                bucket[1] ++;
            }
            else if (values[j] < tests[i].mean - tests[i].stddev) {
                bucket[2] ++;
            }
            else if (values[j] < tests[i].mean) {
                bucket[3] ++;
            }
            else if (values[j] < tests[i].mean + tests[i].stddev) {
                bucket[4] ++;
            }
            else if (values[j] < tests[i].mean + 2.0 * tests[i].stddev) {
                bucket[5] ++;
            }
            else if (values[j] < tests[i].mean + 3.0 * tests[i].stddev) {
                bucket[6] ++;
            }
            else {
                bucket[7] ++;
            }
        }

        for (j = 0; j < n_buckets; j++) {
            double e, x;

            e = bucket_p[j] * n_values;
            x = bucket[j] - e;
            chi2 += x * x / e;
        }

        double chi2_stddev = sqrt(fma(2.0, n_buckets, -2.0));

        assert_float_in_range(chi2,
                              fma(-3.0, chi2_stddev, n_buckets - 1.0),
                              fma(3.0, chi2_stddev, n_buckets - 1.0));
    }

    free(values);
}
const char *const um_group_name = "randutil";
const struct CMUnitTest um_group_tests[] =
{
    cmocka_unit_test(fn_randbs_bits),
    cmocka_unit_test(fn_randbs_zeroes),
    cmocka_unit_test(randi32v_range),
    cmocka_unit_test(randi32v_call_count),
    cmocka_unit_test(randu32v_range),
    cmocka_unit_test(randu32v_call_count),
    cmocka_unit_test(randf32v_range),
    cmocka_unit_test(randf32v_chi2),
    cmocka_unit_test(randi64v_range),
    cmocka_unit_test(randi64v_call_count),
    cmocka_unit_test(randu64v_range),
    cmocka_unit_test(randu64v_call_count),
    cmocka_unit_test(randf64v_range),
    cmocka_unit_test(randf64v_chi2),
    cmocka_unit_test(gaussf32v_gaussf32_same_seq),
    cmocka_unit_test(gaussf32v_mean),
    cmocka_unit_test(gaussf32v_variance),
    cmocka_unit_test(gaussf32v_chi2),
};
const size_t um_group_n_tests = sizeof(um_group_tests)
                                / sizeof(um_group_tests[0]);
CMFixtureFunction um_group_setup = NULL;
CMFixtureFunction um_group_teardown = NULL;

/* vim: set ft=c */
