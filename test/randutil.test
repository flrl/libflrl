#include "test/unitmain.h"

#include "src/randutil.c"

#include "flrl/fputil.h"
#include "flrl/xoshiro.h"

#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* testing the interfaces/distributions, not the underlying randomness */
#define N_VALUES (10000)

static const uint32_t seed128[4] = {
    0x26457b9d,
    0x9c2fdf6b,
    0xd9cdfc7b,
    0x6dc7cdbd,
};

struct mock_rng32_state {
    uint32_t next_index;
    uint32_t call_count;
    uint32_t n_outputs;
    uint32_t outputs[];
};

static uint32_t mock_rng32(void *state__)
{
    struct mock_rng32_state *state = state__;
    uint32_t val;

    if (!state->n_outputs) abort();

    state->call_count ++;

    val = state->outputs[state->next_index ++];

    if (state->next_index >= state->n_outputs)
        state->next_index = 0;

    return val;
}

static void fn_bs_bits(NO_STATE)
{
    uint32_t rng_state[] = {
        0,
        0,
        3,
        0b01010101101010100011001111001100,
        0b00001111111100000000000011111111,
        0b01010101101010100011001111001100,
    };
    const struct {
        unsigned want_bits;
        uint32_t expect_bits;
    } tests[] = {
        {  0, 0b0 },
        {  1, 0b0 },
        {  2, 0b10 },
        {  3, 0b001 },
        {  4, 0b1111 },
        {  5, 0b01100 },
        {  6, 0b010100 },
        {  7, 0b0101101 },
        {  8, 0b11110101 },
        {  9, 0b000001111 },
        { 10, 0b1110000000 },
        { 11, 0b00000011111 },
        { 12, 0b110011110011 },
        { 13, 0b1011010101000 },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    struct rng rng = { .func = mock_rng32, .state = rng_state };
    struct bitstream bs = BITSTREAM_INITIALIZER(&rng);
    unsigned i;

    for (i = 0; i < n_tests; i++) {
        uint32_t v = bs_bits(&bs, tests[i].want_bits);
        assert_int_equal(tests[i].expect_bits, v);
    }

    assert_int_equal(rng_state[1], rng_state[2]);
}

static void fn_bs_zeroes(NO_STATE)
{
    uint32_t rng_state[] = {
        0,
        0,
        9,
        0b00000110000000010000000100000010,
        0b11000000000000000000000000000010,
        0b00000000000000000000000000000001,
        0b10000000000000000110000000000000,
        0b00000000000000000000000000000000,
        0b00000000000000000000000000000000,
        0b00000000000000000000000000001000,
        0b00000000000000000000000000000000,
        0b10000000000000000000000000000000,
    };
    const struct {
        unsigned limit;
        unsigned expect_zeroes;
        uint32_t expect_call_count;
    } tests[] = {
        {  7,  1, 1 },
        {  7,  6, 1 },
        {  7,  7, 1 },
        {  7,  0, 1 },
        {  7,  7, 1 },
        {  7,  1, 1 },
        {  7,  0, 1 },
        {  7,  6, 2 },
        { 15, 15, 2 },
        { 15, 13, 2 },
        { 15,  0, 2 },
        { 15,  0, 3 },
        { 15, 15, 3 },
        { 15, 15, 3 },
        { 15, 14, 4 },
        { 15,  0, 4 },
        { 15, 15, 4 },
        { 15,  1, 4 },
        { 80, 67, 7 },
        { 64, 64, 9 },
        { 32, 27, 9 },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    struct rng rng = { .func = mock_rng32, .state = rng_state };
    struct bitstream bs = BITSTREAM_INITIALIZER(&rng);
    unsigned i;

    for (i = 0; i < n_tests; i++) {
        unsigned zeroes = bs_zeroes(&bs, tests[i].limit);

        assert_int_equal(tests[i].expect_zeroes, zeroes);
        assert_int_equal(tests[i].expect_call_count, rng_state[1]);
    }
}

static void randi32v_range(NO_STATE)
{
    const struct {
        int32_t min;
        int32_t max;
    } tests[] = {
        {         0,         0 },
        {         0,         1 },
        {         1,         0 },
        {        -1,         1 },
        {       -10,         0 },
        {      -100,       -10 },
        {         1,        10 },
        {        10,       100 },
        {      -100,       100 },
        { INT32_MIN, INT32_MAX },
        { INT32_MIN,         0 },
        {         0, INT32_MAX },
        { INT32_MIN, INT32_MIN },
        { INT32_MAX, INT32_MAX },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    const size_t n_values = N_VALUES;
    struct rng rng = RNG_INIT_XOSHIRO128_PLUSPLUS;
    int32_t *values;
    unsigned i;

    memcpy(rng.state, seed128, sizeof(seed128));

    values = calloc(n_values, sizeof(values[0]));
    assert_non_null(values);

    for (i = 0; i < n_tests; i++) {
        int32_t expect_min = tests[i].min;
        int32_t expect_max = tests[i].max;
        int32_t largest = INT32_MIN, smallest = INT32_MAX;
        unsigned j;

        if (expect_min > expect_max) expect_min = expect_max;

        randi32v(&rng, values, n_values, tests[i].min, tests[i].max);

        for (j = 0; j < n_values; j++) {
            if (values[j] > largest) largest = values[j];
            if (values[j] < smallest) smallest = values[j];
            assert_int_in_range(values[j], expect_min, expect_max);
        }

        if (expect_min != expect_max && n_values > 10)
            assert_int_not_equal(smallest, largest);
    }

    free(values);
}

static void randu32v_range(NO_STATE)
{
    const struct {
        uint32_t min;
        uint32_t max;
    } tests[] = {
        {          0,          0 },
        {          0,          1 },
        {          1,          0 },
        {          1,         10 },
        {         10,        100 },
        {          0, UINT32_MAX },
        { UINT32_MAX,          0 },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    const size_t n_values = N_VALUES;
    struct rng rng = RNG_INIT_XOSHIRO128_PLUSPLUS;
    uint32_t *values;
    unsigned i;

    memcpy(rng.state, seed128, sizeof(seed128));

    values = calloc(n_values, sizeof(values[0]));
    assert_non_null(values);

    for (i = 0; i < n_tests; i++) {
        uint32_t expect_min = tests[i].min;
        uint32_t expect_max = tests[i].max;
        uint32_t largest = 0, smallest = UINT32_MAX;
        unsigned j;

        if (expect_min > expect_max) expect_min = expect_max;

        randu32v(&rng, values, n_values, tests[i].min, tests[i].max);

        for (j = 0; j < n_values; j++) {
            if (values[j] > largest) largest = values[j];
            if (values[j] < smallest) smallest = values[j];
            assert_int_in_range(values[j], expect_min, expect_max);
        }

        if (expect_min != expect_max && n_values > 10)
            assert_int_not_equal(smallest, largest);
    }

    free(values);
}

static void randf32v_range(NO_STATE)
{
    const struct {
        double min;
        double max;
    } tests[] = {
        {      0.0,     1.0 },
        {  FLT_MIN,     1.0 },
        {     -0.5,     0.5 },
        {     -1.0,     1.0 },
        {     -2.0,    -1.0 },
        { -FLT_MAX,     0.0 },
//         { -FLT_MAX, FLT_MAX }, /* XXX overflows range */
        {      0.0, FLT_MAX },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    const size_t n_values = N_VALUES;
    struct rng rng = RNG_INIT_XOSHIRO128_PLUSPLUS;
    float *values;
    unsigned i;

    memcpy(rng.state, seed128, sizeof(seed128));

    values = calloc(n_values, sizeof(values[0]));
    assert_non_null(values);

    for (i = 0; i < n_tests; i++) {
        float expect_min = tests[i].min;
        float expect_max = tests[i].max;
        float largest = -INFINITY, smallest = INFINITY;
        unsigned j;

        if (expect_min > expect_max) expect_min = expect_max;

        randf32v(&rng, values, n_values, tests[i].min, tests[i].max);

        for (j = 0; j < n_values; j++) {
            if (values[j] > largest) largest = values[j];
            if (values[j] < smallest) smallest = values[j];

            assert_float_in_range(values[j], expect_min, expect_max);
        }

        if (expect_min != expect_max && n_values > 10)
            assert_float_not_equal(smallest, largest, FLT_EPSILON);
    }

    free(values);
}

static void randi64v_range(NO_STATE)
{
    const struct {
        int64_t min;
        int64_t max;
    } tests[] = {
        {         0,         0 },
        {         0,         1 },
        {         1,         0 },
        {        -1,         1 },
        {       -10,         0 },
        {      -100,       -10 },
        {         1,        10 },
        {        10,       100 },
        {      -100,       100 },
        { INT32_MIN, INT32_MAX },
        { INT32_MIN,         0 },
        {         0, INT32_MAX },
        { INT32_MIN, INT32_MIN },
        { INT32_MAX, INT32_MAX },
        { INT64_MIN, INT64_MAX },
        { INT64_MIN,         0 },
        {         0, INT64_MAX },
        { INT64_MIN, INT64_MIN },
        { INT64_MAX, INT64_MAX },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    const size_t n_values = N_VALUES;
    struct rng rng = RNG_INIT_XOSHIRO128_PLUSPLUS;
    int64_t *values;
    unsigned i;

    memcpy(rng.state, seed128, sizeof(seed128));

    values = calloc(n_values, sizeof(values[0]));
    assert_non_null(values);

    for (i = 0; i < n_tests; i++) {
        int64_t expect_min = tests[i].min;
        int64_t expect_max = tests[i].max;
        int64_t largest = INT64_MIN, smallest = INT64_MAX;
        unsigned j;

        if (expect_min > expect_max) expect_min = expect_max;

        randi64v(&rng, values, n_values, tests[i].min, tests[i].max);

        for (j = 0; j < n_values; j++) {
            if (values[j] > largest) largest = values[j];
            if (values[j] < smallest) smallest = values[j];
            assert_int_in_range(values[j], expect_min, expect_max);
        }

        if (expect_min != expect_max && n_values > 10)
            assert_int_not_equal(smallest, largest);
    }

    free(values);
}

static void randu64v_range(NO_STATE)
{
    const struct {
        uint64_t min;
        uint64_t max;
    } tests[] = {
        {          0,          0 },
        {          0,          1 },
        {          1,          0 },
        {          1,         10 },
        {         10,        100 },
        {          0, UINT32_MAX },
        { UINT32_MAX,          0 },
        {          0, UINT64_MAX },
        { UINT64_MAX,          0 },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    const size_t n_values = N_VALUES;
    struct rng rng = RNG_INIT_XOSHIRO128_PLUSPLUS;
    uint64_t *values;
    unsigned i;

    memcpy(rng.state, seed128, sizeof(seed128));

    values = calloc(n_values, sizeof(values[0]));
    assert_non_null(values);

    for (i = 0; i < n_tests; i++) {
        uint64_t expect_min = tests[i].min;
        uint64_t expect_max = tests[i].max;
        uint64_t largest = 0, smallest = UINT64_MAX;
        unsigned j;

        if (expect_min > expect_max) expect_min = expect_max;

        randu64v(&rng, values, n_values, tests[i].min, tests[i].max);

        for (j = 0; j < n_values; j++) {
            if (values[j] > largest) largest = values[j];
            if (values[j] < smallest) smallest = values[j];
            assert_in_range(values[j], expect_min, expect_max);
        }

        if (expect_min != expect_max && n_values > 10)
            assert_int_not_equal(smallest, largest);
    }

    free(values);
}

static void randf64v_range(NO_STATE)
{
    const struct {
        double min;
        double max;
    } tests[] = {
        {      0.0,     1.0 },
        {  DBL_MIN,     1.0 },
        {     -0.5,     0.5 },
        {     -1.0,     1.0 },
        {     -2.0,    -1.0 },
        { -DBL_MAX,     0.0 },
//         { -DBL_MAX, DBL_MAX }, /* XXX overflows range */
        {      0.0, DBL_MAX },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    const size_t n_values = N_VALUES;
    struct rng rng = RNG_INIT_XOSHIRO128_PLUSPLUS;
    double *values;
    unsigned i;

    memcpy(rng.state, seed128, sizeof(seed128));

    values = calloc(n_values, sizeof(values[0]));
    assert_non_null(values);

    for (i = 0; i < n_tests; i++) {
        double expect_min = tests[i].min;
        double expect_max = tests[i].max;
        double largest = -INFINITY, smallest = INFINITY;
        unsigned j;

        if (expect_min > expect_max) expect_min = expect_max;

        randf64v(&rng, values, n_values, tests[i].min, tests[i].max);

        for (j = 0; j < n_values; j++) {
            if (values[j] > largest) largest = values[j];
            if (values[j] < smallest) smallest = values[j];

            assert_float_in_range(values[j], expect_min, expect_max);
        }

        if (expect_min != expect_max && n_values > 10) {
            /* XXX assert_double_not_equal */
            assert_false(floats_equalish(smallest, largest,
                                         128 * DBL_EPSILON, DBL_MIN));
        }
    }

    free(values);
}

static void gaussf32v_gaussf32_same_seq(NO_STATE)
{
    const struct {
        double mean;
        double stddev;
    } tests[] = {
        { 0.0, 1.0 },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    const size_t n_values = N_VALUES;
    struct rng rng = RNG_INIT_XOSHIRO128_PLUSPLUS;
    float *values;
    unsigned i;

    values = calloc(n_values, sizeof(values[0]));
    assert_non_null(values);

    for (i = 0; i < n_tests; i++) {
        unsigned j;

        memcpy(rng.state, seed128, sizeof(seed128));
        gaussf32v(&rng, values, n_values, tests[i].mean, tests[i].stddev);

        memcpy(rng.state, seed128, sizeof(seed128));
        for (j = 0; j < n_values; j++) {
            float v = gaussf32(&rng, tests[i].mean, tests[i].stddev);

            assert_float_equal(v, values[j], FLT_EPSILON);
        }
    }

    free(values);
}

static void gaussf32v_mean(NO_STATE)
{
    const struct {
        double mean;
        double stddev;
    } tests[] = {
        { 0.0, 1.0 },
        { 4.0, 3.0 },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    const size_t n_values = 1 << 20; /* about a million, as a power of two */
    const double recip_n_values = 1.0 / n_values;
    const double recip_sqrt_n_values = 1.0 / sqrt(n_values);
    struct rng rng = RNG_INIT_XOSHIRO128_PLUSPLUS;
    float *values;
    unsigned i;

    xoshiro128plusplus_seed64(rng.state, time(NULL));

    values = calloc(n_values, sizeof(values[0]));
    assert_non_null(values);

    for (i = 0; i < n_tests; i++) {
        double mean, mean_stddev;

        gaussf32v(&rng, values, n_values, tests[i].mean, tests[i].stddev);
        mean = kbn_sumf32v(values, n_values) * recip_n_values;

        /* the standard deviation of the mean is smaller than the standard
         * deviation of individual samples by a factor of 1/sqrt(n)
         */
        mean_stddev = tests[i].stddev * recip_sqrt_n_values;

        /* should be within 2 standard deviations 95% of the time, and within
         * 3 standard deviations 99.7% of the time
         */
        assert_float_in_range(mean,
                              fma(-3.0, mean_stddev, tests[i].mean),
                              fma(3.0, mean_stddev, tests[i].mean));
    }

    free(values);
}

static void gaussf32v_variance(NO_STATE)
{
    const struct {
        double mean;
        double stddev;
    } tests[] = {
        {  0.0, 1.0 },
        { -2.0, 7.0 },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    const size_t n_values = 1 << 20; /* about a million, as a power of two */
    const double recip_n_values = 1.0 / n_values;
    struct rng rng = RNG_INIT_XOSHIRO128_PLUSPLUS;
    float *values;
    unsigned i;

    xoshiro128plusplus_seed64(rng.state, time(NULL));

    values = calloc(n_values, sizeof(values[0]));
    assert_non_null(values);

    for (i = 0; i < n_tests; i++) {
        const double expected_variance = tests[i].stddev * tests[i].stddev;
        double mean, variance = 0.0, variance_stddev;
        unsigned j;

        gaussf32v(&rng, values, n_values, tests[i].mean, tests[i].stddev);
        mean = kbn_sumf32v(values, n_values) *recip_n_values;

        for (j = 0; j < n_values; j++) {
            double diff = values[j] - mean;

            /* n.b. using population variance rather than sample variance,
             * because x/n plays nicer with floating point than x/(n - 1)
             * when n is a power of 2
             */
            variance += diff * diff * recip_n_values;
        }

        /* sample variance approximately has a normal distribution with mean
         * of stddev^2 and variance of 2*stddev^4 / (n - 1)
         */
        variance_stddev = sqrt(2.0 * pow(tests[i].stddev, 4.0) * recip_n_values);
        assert_float_in_range(variance,
                              fma(-3.0, variance_stddev, expected_variance),
                              fma(3.0, variance_stddev, expected_variance));
    }

    free(values);
}

static void gaussf32v_chi2(NO_STATE)
{
    const struct {
        double mean;
        double stddev;
    } tests[] = {
        {  0.0, 1.0 },
        { -2.0, 7.0 },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    const size_t n_values = 1 << 20; /* about a million, as a power of two */
    const size_t n_buckets = 8;
    const double bucket_p[8] = { 0.00135, 0.0214, 0.1359, 0.34135,
                                 0.34135, 0.1359, 0.0214, 0.00135 };
    struct rng rng = RNG_INIT_XOSHIRO128_PLUSPLUS;
    float *values;
    unsigned i;

    xoshiro128plusplus_seed64(rng.state, time(NULL));

    values = calloc(n_values, sizeof(values[0]));
    assert_non_null(values);

    for (i = 0; i < n_tests; i++) {
        double chi2 = 0.0;
        unsigned bucket[8] = { 0 };
        unsigned j;

        gaussf32v(&rng, values, n_values, tests[i].mean, tests[i].stddev);

        for (j = 0; j < n_values; j++) {
            if (values[j] < tests[i].mean - 3.0 * tests[i].stddev) {
                bucket[0] ++;
            }
            else if (values[j] < tests[i].mean - 2.0 * tests[i].stddev) {
                bucket[1] ++;
            }
            else if (values[j] < tests[i].mean - tests[i].stddev) {
                bucket[2] ++;
            }
            else if (values[j] < tests[i].mean) {
                bucket[3] ++;
            }
            else if (values[j] < tests[i].mean + tests[i].stddev) {
                bucket[4] ++;
            }
            else if (values[j] < tests[i].mean + 2.0 * tests[i].stddev) {
                bucket[5] ++;
            }
            else if (values[j] < tests[i].mean + 3.0 * tests[i].stddev) {
                bucket[6] ++;
            }
            else {
                bucket[7] ++;
            }
        }

        for (j = 0; j < n_buckets; j++) {
            double e, x;

            e = bucket_p[j] * n_values;
            x = bucket[j] - e;
            chi2 += x * x / e;
        }

        double chi2_stddev = sqrt(fma(2.0, n_buckets, -2.0));

        assert_float_in_range(chi2,
                              fma(-3.0, chi2_stddev, n_buckets - 1.0),
                              fma(3.0, chi2_stddev, n_buckets - 1.0));
    }

    free(values);
}
const char *const um_group_name = "randutil";
const struct CMUnitTest um_group_tests[] =
{
    cmocka_unit_test(fn_bs_bits),
    cmocka_unit_test(fn_bs_zeroes),
    cmocka_unit_test(randi32v_range),
    cmocka_unit_test(randu32v_range),
    cmocka_unit_test(randf32v_range),
    cmocka_unit_test(randi64v_range),
    cmocka_unit_test(randu64v_range),
    cmocka_unit_test(randf64v_range),
    cmocka_unit_test(gaussf32v_gaussf32_same_seq),
    cmocka_unit_test(gaussf32v_mean),
    cmocka_unit_test(gaussf32v_variance),
    cmocka_unit_test(gaussf32v_chi2),
};
const size_t um_group_n_tests = sizeof(um_group_tests)
                                / sizeof(um_group_tests[0]);
CMFixtureFunction um_group_setup = NULL;
CMFixtureFunction um_group_teardown = NULL;

/* vim: set ft=c */
