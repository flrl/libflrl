#include "test/unitmain.h"

#include "src/statsutil.c"

#include "flrl/randutil.h"

#include <float.h>
#include <math.h>

#define TEST_EPSILON (0) /* XXX not actually used by assert_float_equal()! */

static void fn_meani8v(NO_STATE)
{
    const struct {
        int8_t values[8];
        size_t n_values;
        double expect;
    } tests[] = {
        { {},
          0, NAN },
        { { 0, 0, 0, 0, 0, 0, 0, 0 },
          8, 0.0 },
        { { -1, 0, +1 },
          3, 0.0 },
        { { 12, 20, 111 },
          3, 47.667 },
        { { INT8_MIN, INT8_MAX },
          2, -0.5 },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    unsigned i;

    for (i = 0; i < n_tests; i++) {
        double actual = meani8v(tests[i].values, tests[i].n_values);

        assert_float_equal(actual, tests[i].expect, TEST_EPSILON);
    }
}

static void fn_mediani8v(NO_STATE)
{
    const struct {
        int8_t values[8];
        size_t n_values;
        double expect;
    } tests[] = {
        { {},
          0, NAN },
        { { 0, 0, 0, 0, 0, 0, 0, 0 },
          8, 0.0 },
        { { -1, 0, +1 },
          3, 0.0 },
        { { 12, 20, 111 },
          3, 20.0 },
        { { INT8_MIN, INT8_MAX },
          2, -0.5 },
        { { INT8_MIN, 12, INT8_MAX },
          3, 12.0 },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    unsigned i;

    for (i = 0; i < n_tests; i++) {
        double actual = mediani8v(tests[i].values, tests[i].n_values);

        assert_float_equal(actual, tests[i].expect, TEST_EPSILON);
    }
}

static void fn_modei8v(NO_STATE)
{
    const struct {
        int8_t values[8];
        size_t n_values;
        int8_t expect_mode;
        size_t expect_frequency;
    } tests[] = {
        { {},
          0, 0, 0 },
        { { 0, 0, 0, 0, 0, 0, 0, 0 },
          8, 0, 8 },
        { { -1, 0, 1, 0 },
          4, 0, 2 },
        { { 12, 20, 111, 12, 20, 12 },
          6, 12, 3 },
        { { INT8_MIN, INT8_MIN, INT8_MAX },
          3, INT8_MIN, 2 },
        { { INT8_MIN, 12, 12 },
          3, 12, 2 },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    unsigned i;

    for (i = 0; i < n_tests; i++) {
        size_t actual_frequency;

        int8_t actual_mode = modei8v(tests[i].values, tests[i].n_values,
                                     &actual_frequency);

        assert_int_equal(actual_mode, tests[i].expect_mode);
        assert_int_equal(actual_frequency, tests[i].expect_frequency);
    }
}

static void fn_variancei8v(NO_STATE)
{
    const struct {
        int8_t values[8];
        size_t n_values;
        double expect;
    } tests[] = {
        { {},
          0, NAN },
        { { 0, 0, 0, 0, 0, 0, 0, 0 },
          8, 0.0 },
        { { -1, 0, 1, 0 },
          4, 0.66667 },
        { { 12, 20, 111, 12, 20, 12 },
          6, 1544.9667 },
        { { INT8_MIN, INT8_MIN, INT8_MAX },
          3, 21675.0 },
        { { INT8_MIN, 12, 12 },
          3, 6533.333 },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    unsigned i;

    for (i = 0; i < n_tests; i++) {
        double mean = meani8v(tests[i].values, tests[i].n_values);

        double actual = variancei8v(tests[i].values, tests[i].n_values, mean);

        assert_float_equal(actual, tests[i].expect, TEST_EPSILON);
    }
}

#define do_test_stats(ctype, ftype, min, max) do                            \
{                                                                           \
    ctype *values = NULL;                                                   \
    const size_t n_values = 10000;                                          \
    double expect_mean, expect_variance;                                    \
    double actual_mean = nan(""), actual_variance = nan("");                \
                                                                            \
    values = calloc(n_values, sizeof(values[0]));                           \
    assert_non_null(values);                                                \
                                                                            \
    rand##ftype##v(rbs, values, n_values, min, max);                        \
                                                                            \
    expect_mean = mean##ftype##v(values, n_values);                         \
    expect_variance = variance##ftype##v(values, n_values, expect_mean);    \
                                                                            \
    stats##ftype##v(values, n_values,                                       \
                    NULL, NULL,                                             \
                    NULL, NULL,                                             \
                    &actual_mean, &actual_variance);                        \
                                                                            \
    assert_float_equal(actual_mean, expect_mean, TEST_EPSILON);             \
    assert_float_equal(actual_variance, expect_variance, TEST_EPSILON);     \
                                                                            \
    free(values);                                                           \
} while (0)

static void fn_statsi8v(void **state)
{
    struct randbs *rbs = *state;

    do_test_stats(int8_t, i8, INT8_MIN, INT8_MAX);
}

static void fn_statsu8v(void **state)
{
    struct randbs *rbs = *state;

    do_test_stats(uint8_t, u8, 0, UINT8_MAX);
}

static void fn_statsi16v(void **state)
{
    struct randbs *rbs = *state;

    do_test_stats(int16_t, i16, INT16_MIN, INT16_MAX);
}

static void fn_statsu16v(void **state)
{
    struct randbs *rbs = *state;

    do_test_stats(uint16_t, u16, 0, UINT16_MAX);
}

static void fn_statsi32v(void **state)
{
    struct randbs *rbs = *state;

    do_test_stats(int32_t, i32, INT32_MIN, INT32_MAX);
}

static void fn_statsu32v(void **state)
{
    struct randbs *rbs = *state;

    do_test_stats(uint32_t, u32, 0, UINT32_MAX);
}

static void fn_statsi64v(void **state)
{
    struct randbs *rbs = *state;

    do_test_stats(int64_t, i64, INT64_MIN, INT64_MAX);
}

static void fn_statsu64v(void **state)
{
    struct randbs *rbs = *state;

    do_test_stats(uint64_t, u64, 0, UINT64_MAX);
}

static void fn_statsf32v(void **state)
{
    struct randbs *rbs = *state;

    do_test_stats(float, f32, 0, FLT_MAX);
    do_test_stats(float, f32, -FLT_MAX, 0);
}

static void fn_statsf64v(void **state)
{
    struct randbs *rbs = *state;

    do_test_stats(double, f64, 0, DBL_MAX);
    do_test_stats(double, f64, -DBL_MAX, 0);
}

#define do_test_summary5(ctype, ftype) do                                   \
{                                                                           \
    const struct {                                                          \
        size_t n_values;                                                    \
        ctype  values[16];                                                  \
        int    expect_r;                                                    \
        double expect_quartiles[5];                                         \
    } tests[] = {                                                           \
        { 11, { 6, 7, 15, 36, 39, 40, 41, 42, 43, 47, 49 }, /* 4x + 3 */    \
          0, { 6, 15, 40, 43, 49 } },                                       \
        { 11, { 15, 7, 43, 36, 42, 40, 41, 39, 6, 47, 49 }, /* unsorted */  \
          0, { 6, 15, 40, 43, 49 } },                                       \
        { 9, { 13, 13, 14, 64, 68, 85, 91, 97, 127 }, /* 4x + 1 */          \
          0, { 13, 13.5, 68, 94, 127 } },                                   \
        { 6, { 7, 15, 36, 39, 40, 41 }, /* 4x + 2 */                        \
          0, { 7, 13, 37.5, 40.25, 41 } },                                  \
        { 4, { 6, 10, 17, 22 }, /* 4x + 0 */                                \
          0, { 6, 7, 13.5, 20.75, 22 } },                                   \
        { 3, { 9, 20, 64 },                                                 \
          0, { 9, NAN, 20, NAN, 64 } },                                     \
        { 2, { 6, 9 },                                                      \
          0, { 6, NAN, 7.5, NAN, 9 } },                                     \
        { 2, { 9, 6 },                                                      \
          0, { 6, NAN, 7.5, NAN, 9 } },                                     \
        { 1, { 42 },                                                        \
          0, { 42, NAN, NAN, NAN, 42 } },                                   \
        { 0, {},                                                            \
          0, { NAN, NAN, NAN, NAN, NAN } },                                 \
    };                                                                      \
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);                \
    unsigned i;                                                             \
                                                                            \
    for (i = 0; i < n_tests; i++) {                                         \
        double actual_quartiles[5];                                         \
        int q, r;                                                           \
                                                                            \
        r = summary5##ftype##v(tests[i].values, tests[i].n_values,          \
                               actual_quartiles);                           \
                                                                            \
        assert_int_equal(r, tests[i].expect_r);                             \
        for (q = 0; q < 5; q++) {                                           \
            assert_float_equal(actual_quartiles[q],                         \
                               tests[i].expect_quartiles[q],                \
                               FLT_EPSILON);                                \
        }                                                                   \
    }                                                                       \
} while (0)

static void fn_summary5i8v(NO_STATE)
{
    do_test_summary5(int8_t, i8);
}

static void fn_summary5u8v(NO_STATE)
{
    do_test_summary5(uint8_t, u8);
}

static void fn_summary5i16v(NO_STATE)
{
    do_test_summary5(int16_t, i16);
}

static void fn_summary5u16v(NO_STATE)
{
    do_test_summary5(uint16_t, u16);
}

static void fn_summary5i32v(NO_STATE)
{
    do_test_summary5(int32_t, i32);
}

static void fn_summary5u32v(NO_STATE)
{
    do_test_summary5(uint32_t, u32);
}

static void fn_summary5i64v(NO_STATE)
{
    do_test_summary5(int64_t, i64);
}

static void fn_summary5u64v(NO_STATE)
{
    do_test_summary5(uint64_t, u64);
}

static void fn_summary5f32v(NO_STATE)
{
    do_test_summary5(float, f32);
}

static void fn_summary5f64v(NO_STATE)
{
    do_test_summary5(double, f64);
}

static void fn_summary5_nan(NO_STATE)
{
    const struct {
        size_t n_values;
        double values[16];
        int    expect_r;
        double expect_quartiles[5];
    } tests[] = {
        { 8, { 5, 6, NAN, 7, 8, 9, 10, 11 },
          0, { 5, 6, 8, 10, 11 } },
        { 8, { 5, 6, 7, NAN, NAN, NAN, NAN, NAN },
          0, { 5, NAN, 6, NAN, 7 } },
        { 8, { 5, 7, NAN, NAN, NAN, NAN, NAN, NAN },
          0, { 5, NAN, 6, NAN, 7 } },
        { 8, { 5, NAN, NAN, NAN, NAN, NAN, NAN, NAN },
          0, { 5, NAN, NAN, NAN, 5 } },
        { 8, { NAN, NAN, NAN, NAN, NAN, NAN, NAN, NAN },
          0, { NAN, NAN, NAN, NAN, NAN } },
        { 2, { NAN, 5 },
          0, { 5, NAN, NAN, NAN, 5 } },
        { 1, { NAN },
          0, { NAN, NAN, NAN, NAN, NAN } },
    };
    const size_t n_tests = sizeof(tests) / sizeof(tests[0]);
    unsigned i;

    for (i = 0; i < n_tests; i++) {
        double actual_quartiles[5];
        int q, r;

        r = summary5f64v(tests[i].values, tests[i].n_values, actual_quartiles);

        assert_int_equal(tests[i].expect_r, r);

        for (q = 0; q < 5; q++) {
            assert_float_equal(tests[i].expect_quartiles[q],
                               actual_quartiles[q],
                               FLT_EPSILON);
        }
    }
}

const char *const um_group_name = "statsutil";
const struct CMUnitTest um_group_tests[] =
{
    cmocka_unit_test(fn_meani8v),
    cmocka_unit_test(fn_mediani8v),
    cmocka_unit_test(fn_modei8v),
    cmocka_unit_test(fn_variancei8v),
    cmocka_unit_test_setup(fn_statsi8v, um_setup_rbs),
    cmocka_unit_test_setup(fn_statsu8v, um_setup_rbs),
    cmocka_unit_test_setup(fn_statsi16v, um_setup_rbs),
    cmocka_unit_test_setup(fn_statsu16v, um_setup_rbs),
    cmocka_unit_test_setup(fn_statsi32v, um_setup_rbs),
    cmocka_unit_test_setup(fn_statsu32v, um_setup_rbs),
    cmocka_unit_test_setup(fn_statsi64v, um_setup_rbs),
    cmocka_unit_test_setup(fn_statsu64v, um_setup_rbs),
    cmocka_unit_test_setup(fn_statsf32v, um_setup_rbs),
    cmocka_unit_test_setup(fn_statsf64v, um_setup_rbs),
    cmocka_unit_test(fn_summary5i8v),
    cmocka_unit_test(fn_summary5u8v),
    cmocka_unit_test(fn_summary5i16v),
    cmocka_unit_test(fn_summary5u16v),
    cmocka_unit_test(fn_summary5i32v),
    cmocka_unit_test(fn_summary5u32v),
    cmocka_unit_test(fn_summary5i64v),
    cmocka_unit_test(fn_summary5u64v),
    cmocka_unit_test(fn_summary5f32v),
    cmocka_unit_test(fn_summary5f64v),
    cmocka_unit_test(fn_summary5_nan),
};
const size_t um_group_n_tests = sizeof(um_group_tests)
                                / sizeof(um_group_tests[0]);
CMFixtureFunction um_group_setup = NULL;
CMFixtureFunction um_group_teardown = NULL;

/* vim: set ft=c :*/
